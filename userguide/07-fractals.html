<!doctype html>
<notebook theme="air">
  <title>7. Fractals</title>
  <script id="0" type="text/markdown">
    # 7. Fractals

    Walks offer an internal structure only when we force them to pass through predefined points with fitted kernels. Fractals are mathematical sets that exhibit a repeating pattern at every scale. They have not only captivated mathematicians and scientists, but have also found a fascinating application in the world of music. The concept of fractals in music revolves around the idea of using these self-similar patterns to create compositions that can vary in complexity, embodying both a sense of infinity and a coherent structure. This approach to music composition allows for the exploration of new textures, forms, and sonic landscapes, pushing the boundaries of traditional musical creativity. Fractals inspired modern composers Jessie Montgomery in [Rounds for Piano and Orchestra](https://www.youtube.com/watch?v=eMYG_w6ueUg) and Dinuk Wijeratne in [Invisible cities](https://www.youtube.com/watch?v=sAK8aqAdUCA&t=1424s). jmon/algo has three types of fractals: **cellular automata** (self-organizing systems governed by simple rules in a discrete grid), **Mandelbrot** (complex and infinitely detailed fractal structure), and **logistic map** (a simple mathematical model illustrating chaos theory).
  </script>
  <script id="1" type="module" pinned="">
    import jm from "../src/index.js";
    import * as Tone from "npm:tone";
    import verovio from "npm:verovio@4.3.1/wasm";
    import * as Plot from "npm:@observablehq/plot@0.6";
  </script>
  <script id="2" type="text/markdown">
    ## Cellular automata

    Genius composer Iannis Xenakis might have been the first to popularize (or even to use) cellular automata in music with his orchestral work [Horos](https://www.youtube.com/watch?v=9aYsh8SRB-c) in 1986 ([Solomos, 2013](https://hal.science/hal-00770141)). This section applies a rather simple method to compose music with cellular automata, and can be summarized in three steps:

    1. Select a rule (among the 256 presented in the [Wolfram atlas](http://atlas.wolfram.com/01/01/)) and the initial state, then draw the cells.
    2. Select a strip along the sequence dimension.
    3. Apply notes and durations to transform the strip to a [digital piano roll](https://en.wikipedia.org/wiki/Piano_roll#In_digital_audio_workstations).

    ### Understanding cellular automata

    You can create an interesting score by hand, but inductively trying all sorts of scores, or complexifying the process by hand can be laborious. This is where jmon/algo can help. We can start by plotting a few cellular automata rules, with a single cell initiating the pattern at the centre of the first sequence.
  </script>
  <script id="3" type="module">
    // Visualize several CA rules
    const width = 20;
    const iterations = 10;
    const initialState = Array(width).fill(0);
    initialState[Math.floor(width / 2)] = 1;

    const rules = [18, 22, 30, 45, 54, 60, 73, 102, 105, 110, 126, 150];

    // Generate CA grids for each rule
    const caGrids = rules.map(ruleNumber => {
      const ca = new jm.generative.automata.Cellular({
    ruleNumber: ruleNumber,
    width: width,
    initialState: initialState
      });
      ca.generate(iterations);
      return { rule: ruleNumber, ca };
    });

    // Create plots for each rule
    const plots = caGrids.map(({ rule, ca }) => {
      const plotData = ca.toPlotData();

      return html`<div style="display: inline-block; margin: 10px;">
    <div style="text-align: center; font-weight: bold; margin-bottom: 5px;">Rule ${rule}</div>
    ${Plot.plot({
      width: 200,
      height: 200,
      marginLeft: 0,
      marginRight: 0,
      marginTop: 0,
      marginBottom: 0,
      x: { axis: null },
      y: { axis: null },
      marks: [
        Plot.dot(plotData, { x: "time", y: "pitch", fill: "black", r: 5, symbol: "square" })
      ]
    })}
      </div>`;
    });

    display(html`<div style="display: flex; flex-wrap: wrap; justify-content: center;">${plots}</div>`);
  </script>
  <script id="4" type="text/markdown">
    ### Steps 1 and 2. Generate cellular automata and select strips

    We'll create three tracks for a traditional minimal rock band with an electric guitar, an electric bass and a drum kit. The first cellular automaton will create piano rolls for the guitar and the bass. [Rule 150](http://atlas.wolfram.com/01/01/150/) seemed appropriate. A width of 200 cells will provide a good overview of the cellular automata. We'll use 136 steps to obtain a musical piece a bit shorter than 1:13.
  </script>
  <script id="5" type="module" pinned="">
    // Generate cells for guitar and bass
    const ca1Rule = 150;
    const width1 = 200;
    const length1 = 136;
    const init1 = Array(width1).fill(0);
    init1[Math.floor(width1 / 2)] = 1;

    const ca1 = new jm.generative.automata.Cellular({
      ruleNumber: ca1Rule,
      width: width1,
      initialState: init1
    });

    const ca1Grid = ca1.generate(length1);
    display("Generated CA grid with " + ca1Grid.length + " rows");
  </script>
  <script id="6" type="text/markdown">
    Let's visualize this cellular automaton with a heatmap:
  </script>
  <script id="7" type="module">
    // Plot the full CA grid
    const ca1PlotData = ca1.toPlotData(ca1Grid);

    display(Plot.plot({
      title: "Rule 150 - Guitar and Bass source",
      width: 800,
      height: 500,
      x: {
    label: "Time (steps)",
    ticks: Array.from({ length: 8 }, (_, i) => i * 20).concat([136])
      },
      y: {
    label: "Pitch (cell index)",
    ticks: [0, 25, 50, 75, 100, 125, 150, 175, 200]
      },
      marks: [
    Plot.dot(ca1PlotData, { x: "time", y: "pitch", fill: "black", r: 2 })
      ]
    }));
  </script>
  <script id="8" type="text/markdown">
    From this plot, we'll select two strips: a guitar line playing all along the piece, and bass to jump in a little later. The strips are defined as `[minIndex, maxIndex]` ranges along the width axis.
  </script>
  <script id="9" type="module" pinned="">
    const strips1 = [[97, 103], [85, 92]];
    display("Selected strips: " + JSON.stringify(strips1));

    // Visualize the selected strips
    const strips1PlotData = ca1PlotData.map(d => {
      let strip = null;
      if (d.pitch >= strips1[0][0] && d.pitch <= strips1[0][1]) {
    strip = "Guitar (97-103)";
      } else if (d.pitch >= strips1[1][0] && d.pitch <= strips1[1][1]) {
    strip = "Bass (85-92)";
      }
      return { ...d, strip };
    }).filter(d => d.strip !== null);

    display(Plot.plot({
      title: "Rule 150 with selected strips",
      width: 800,
      height: 500,
      color: { legend: true },
      x: {
    label: "Time (steps)",
    ticks: Array.from({ length: 8 }, (_, i) => i * 20).concat([136])
      },
      y: {
    label: "Pitch (cell index)",
    ticks: [0, 25, 50, 75, 100, 125, 150, 175, 200]
      },
      marks: [
    Plot.dot(ca1PlotData, { x: "time", y: "pitch", fill: "#e0e0e0", r: 2 }),
    Plot.dot(strips1PlotData, { x: "time", y: "pitch", fill: "strip", r: 2 })
      ]
    }));
  </script>
  <script id="10" type="text/markdown">
    The cellular automata process used for the guitar and the bass felt too dense with too many blank regions to generate good drumming. We'll try a less dense rule set (Rule 18), with a random initial condition, then select a region that allows drums to kick in after a few beats in the piece.
  </script>
  <script id="11" type="module" pinned="">
    // Generate cells for drums with Rule 18
    const ca2Rule = 18;
    const width2 = [100, 125];
    const length2 = 136;

    // Create random initial state (Math.random with no seed control in Observable)
    const init2 = Array(width2[1] - width2[0] + 1).fill(0).map(() => Math.random() < 0.1 ? 1 : 0);
    const ca2 = new jm.generative.automata.Cellular({
      ruleNumber: ca2Rule,
      width: width2,
      initialState: init2
    });

    const ca2Grid = ca2.generate(length2);

    // Define strip in pitch values, then convert to indices for extraction
    const strips2Pitch = [[110, 116]];
    const strips2 = [[strips2Pitch[0][0] - width2[0], strips2Pitch[0][1] - width2[0]]];
    display("Drum strip (pitch): " + JSON.stringify(strips2Pitch));
    display("Drum strip (indices): " + JSON.stringify(strips2));

    // Plot the CA for drums
    const ca2PlotData = ca2.toPlotData(ca2Grid);

    const strips2PlotData = ca2PlotData.map(d => {
      let strip = null;
      if (d.pitch >= strips2Pitch[0][0] && d.pitch <= strips2Pitch[0][1]) {
    strip = "Drums (110-116)";
      }
      return { ...d, strip };
    }).filter(d => d.strip !== null);

    display(Plot.plot({
      title: "Rule 18 with drum strip",
      width: 800,
      height: 250,
      color: { legend: true },
      x: {
    label: "Time (steps)",
    ticks: Array.from({ length: 8 }, (_, i) => i * 20).concat([136])
      },
      y: {
    label: "Pitch (MIDI)",
    ticks: [100, 105, 110, 115, 120, 125]
      },
      marks: [
    Plot.dot(ca2PlotData, { x: "time", y: "pitch", fill: "#e0e0e0", r: 3 }),
    Plot.dot(strips2PlotData, { x: "time", y: "pitch", fill: "strip", r: 3 })
      ]
    }));
  </script>
  <script id="12" type="text/markdown">
    We can extract these strips to see them more clearly:
  </script>
  <script id="13" type="module">
    // Extract and plot strips
    const extractStrip = (grid, stripRange) => {
      return grid.map(row => row.slice(stripRange[0], stripRange[1] + 1));
    };

    const guitarStrip = extractStrip(ca1Grid, strips1[0]);
    const bassStrip = extractStrip(ca1Grid, strips1[1]);
    const drumStrip = extractStrip(ca2Grid, strips2[0]);

    const plotStrip = (strip, title) => {
      const data = jm.generative.automata.Cellular.gridToPlotData(strip);

      const numTimeSteps = strip.length;
      const numPitches = strip[0].length;

      return Plot.plot({
    title,
    width: numTimeSteps * 6,
    height: numPitches * 15,
    marginLeft: 50,
    marginRight: 20,
    x: {
      label: "Time",
      ticks: Array.from({ length: 8 }, (_, i) => i * 20).concat([numTimeSteps - 1])
    },
    y: {
      label: "Pitch"
    },
    marks: [
      Plot.dot(data, { x: "time", y: "pitch", fill: "black", r: 3 })
    ]
      });
    };

    display(html`
      <div style="display: flex; flex-direction: column; gap: 20px;">
    <div>${plotStrip(guitarStrip, "Guitar")}</div>
    <div>${plotStrip(bassStrip, "Bass")}</div>
    <div>${plotStrip(drumStrip, "Drums")}</div>
      </div>
    `);
  </script>
  <script id="14" type="text/markdown">
    ### Step 3. Generate pitches

    The strips can now be converted to pitches. We'll use a C-minor scale for the guitar and bass. Each column in the strip represents a pitch position in our scale.
  </script>
  <script id="15" type="module" pinned="">
    // Define pitch sets (C minor scale)
    const guitarPitchSet = ["C4", "D4", "Eb4", "F4", "G4", "Ab4", "Bb4"]
      .map(p => jm.utils.cdeToMidi(p));
    const bassPitchSet = ["C3", "D3", "Eb3", "F3", "G3", "Ab3", "Bb3"]
      .map(p => jm.utils.cdeToMidi(p));
    const drumPitchSet = ["G3", "Ab3", "Bb3", "C4", "D4", "Eb4", "F4"]
      .map(p => jm.utils.cdeToMidi(p));

    display("Guitar pitches: " + guitarPitchSet);
    display("Bass pitches: " + bassPitchSet);
    display("Drum pitches: " + drumPitchSet);
  </script>
  <script id="16" type="text/markdown">
    Now we convert each strip to pitch sequences. Each row in the strip becomes a chord (multiple pitches sounding together) or a single note.
  </script>
  <script id="17" type="module" pinned="">
    // Convert strips to pitch sequences using the built-in method
    const guitarPitches = jm.generative.automata.Cellular.stripToPitches(guitarStrip, guitarPitchSet);
    const bassPitches = jm.generative.automata.Cellular.stripToPitches(bassStrip, bassPitchSet);
    const drumPitches = jm.generative.automata.Cellular.stripToPitches(drumStrip, drumPitchSet);

    display("Guitar pitch sequence (first 10): " + guitarPitches.slice(0, 10));
    display("Bass pitch sequence (first 10): " + bassPitches.slice(0, 10));
  </script>
  <script id="18" type="text/markdown">
    ### Step 4. Map pitches to notes

    The `beatcycle` function zips cycling durations onto the pitches to generate streams of notes in jmon/algo's format (pitch, duration, time).
  </script>
  <script id="19" type="module" pinned="">
    // Apply durations to create notes
    const guitarNotes = jm.theory.rhythm.beatcycle(
      guitarPitches,
      [0.5, 0.5, 1, 2, 1, 1, 0.5, 1.5]
    );

    const bassNotes = jm.theory.rhythm.beatcycle(
      bassPitches,
      [1, 1, 2, 0.5, 0.5, 0.5, 0.5, 2]
    );

    const drumNotes = jm.theory.rhythm.beatcycle(
      drumPitches,
      [2, 1, 1, 0.5, 0.5, 1, 1, 1]
    );

    display("Guitar notes (first 5):");
    display(guitarNotes.slice(0, 5));
  </script>
  <script id="20" type="text/markdown">
    To make the bass track sound right, we might prefer to play it one note at a time, not chords. We can iterate through the pitches and when we encounter an array, take the first element.
  </script>
  <script id="21" type="module" pinned="">
    // Convert bass chords to single notes
    const bassNotesSingle = bassNotes.map(note => {
      if (Array.isArray(note.pitch)) {
    // If array is empty, preserve null; otherwise take first element
    return { ...note, pitch: note.pitch.length > 0 ? note.pitch[0] : null };
      }
      return note;
    });

    display("Bass notes (single pitches, first 5):");
    display(bassNotesSingle.slice(0, 5));
  </script>
  <script id="22" type="text/markdown">
    Now let's play all three tracks together:
  </script>
  <script id="23" type="module" pinned="">
    const caPiece = {
      title: "T-Cells Vogue - Cellular Automata",
      tempo: 120,
      tracks: [
    { label: "Guitar", notes: guitarNotes, synth: 27 },
    { label: "Bass", notes: bassNotesSingle, synth: 32 },
    { label: "Drums", notes: drumNotes, synth: 0 }
      ]
    };

    display(await jm.score(caPiece, { verovio }));
    display(await jm.play(caPiece, { Tone }));
  </script>
  <script id="24" type="text/markdown">
    Because cellular automata generate repeating patterns, they perform nicely for rhythmic parts. However, they will fall short for melodies.

    ### Using pitch ranges directly

    Instead of always starting at pitch index 0, you can specify a pitch range directly. This is useful when you want to work within a specific MIDI range. For example, we can create a cellular automaton that generates patterns in the MIDI range 60-72 (one octave from C4 to C5):
  </script>
  <script id="25" type="module" pinned="">
    // Create CA with specific pitch range [60, 72]
    const rangeCa = new jm.generative.automata.Cellular({
      ruleNumber: 110,
      width: [60, 72],  // MIDI pitches C4 to C5
    });

    const rangeGrid = rangeCa.generate(20);
    const rangePlotData = rangeCa.toPlotData();

    display(Plot.plot({
      title: "Rule 110 with pitch range [60, 72]",
      width: 500,
      height: 300,
      x: {
    label: "Time (steps)",
    ticks: [0, 5, 10, 15, 20]
      },
      y: {
    label: "MIDI Pitch",
    ticks: [60, 62, 64, 66, 68, 70, 72]
      },
      marks: [
    Plot.dot(rangePlotData, { x: "time", y: "pitch", fill: "black", r: 3 })
      ]
    }));

    display("The toPlotData() method automatically maps cell indices to the specified pitch range.");
    display("Pitch values in the data: " + rangePlotData.slice(0, 5).map(d => d.pitch).join(", ") + "...");
  </script>
  <script id="26" type="text/markdown">
    ### Rotating CA

    Another way of transforming cellular automata to music is to rotate the strips. We will use drum CA to create drums. In the following code block, we'll use three different rules initiated randomly for kick, snare and hi-hat.
  </script>
  <script id="27" type="module" pinned="">
    // Create three separate CAs for drum parts
    const instruments = ["kick", "snare", "hat"];
    const drumRules = [30, 54, 150];
    const drumWidth = 12;
    const drumLength = 4;

    const drumCAs = instruments.map((instrument, i) => {
      const init = Array(drumWidth).fill(0).map(() => Math.random() < 0.25 ? 1 : 0);
      const ca = new jm.generative.automata.Cellular({
    ruleNumber: drumRules[i],
    width: drumWidth,
    initialState: init
      });
      const grid = ca.generate(drumLength);
      return { instrument, rule: drumRules[i], grid };
    });

    // Plot each drum CA
    const drumPlots = drumCAs.map(({ instrument, rule, grid }) => {
      const data = jm.generative.automata.Cellular.gridToPlotData(grid);

      return html`<div style="display: inline-block; margin: 10px;">
    <div style="text-align: center; font-weight: bold; margin-bottom: 5px;">${instrument} (Rule ${rule})</div>
    ${Plot.plot({
      width: 200,
      height: 200,
      x: {
        label: "Time",
        ticks: 4
      },
      y: {
        label: "Pitch",
        ticks: 4
      },
      marks: [
        Plot.dot(data, { x: "time", y: "pitch", fill: "black", r: 2 })
      ]
    })}
      </div>`;
    });

    display(html`<div style="display: flex; justify-content: center;">${drumPlots}</div>`);
  </script>
  <script id="28" type="text/markdown">
    Now instead of extracting a strip as we have done before, we can flatten the 0 and 1 array on the iteration axis to generate a single line of 0 and 1 per instrument.
  </script>
  <script id="29" type="module" pinned="">
    // Flatten the grids
    const drum01 = drumCAs.map(({ instrument, grid }) => {
      const flat = grid.flat();
      display(instrument + ": " + flat.slice(0, 20).join(" "));
      return flat;
    });
  </script>
  <script id="30" type="text/markdown">
    In our instrument, a kick is pitch 36, a snare is pitch 38 and a hi-hat is pitch 42. Each beat is of quarter length 1.
  </script>
  <script id="31" type="module" pinned="">
    const drum01Pitches = [36, 38, 42];
    const drum01Duration = 1;

    // Convert 0/1 patterns to notes
    const drumTracks = drum01.map((pattern, i) => {
      const notes = [];
      let currentOffset = 0;

      pattern.forEach(hit => {
    if (hit === 1) {
      notes.push({
        pitch: drum01Pitches[i],
        duration: drum01Duration,
        time: currentOffset
      });
    }
    currentOffset += drum01Duration;
      });

      return notes;
    });

    display("Kick track (first 5):");
    display(drumTracks[0].slice(0, 5));
  </script>
  <script id="32" type="text/markdown">
    Let's play these drum patterns:
  </script>
  <script id="33" type="module" pinned="">
    const drumPiece = {
      title: "Rotating CA Drums",
      tempo: 240,
      tracks: instruments.map((name, i) => ({
    label: name,
    notes: drumTracks[i],
    synth: 0
      }))
    };

    display(await jm.play(drumPiece, { Tone }));
  </script>
  <script id="34" type="text/markdown">
    ## Mandelbrot

    You might already have seen the intriguing plot of the Mandelbrot set. `jmon/algo` implements a Mandelbrot fractal generator, which can creatively be used to generate musical patterns based on fractal data.

    The Mandelbrot set is generated by iterating the complex function `z = z¬≤ + c` for each point `c` in the complex plane, and counting how many iterations it takes to escape to infinity (or declaring it never escapes).
  </script>
  <script id="35" type="module" pinned="">
    // Generate basic Mandelbrot set
    const mb = new jm.generative.fractals.Mandelbrot({
      width: 400,
      height: 400,
      xMin: -2.0,
      xMax: 1.0,
      yMin: -1.5,
      yMax: 1.5,
      maxIterations: 100
    });

    const mbData = mb.generate();
  </script>
  <script id="36" type="text/markdown">
    Let's visualize the Mandelbrot set:
  </script>
  <script id="37" type="module">
    const mbPlotData = [];
    mbData.forEach((row, y) => {
      row.forEach((value, x) => {
    mbPlotData.push({ x, y, value });
      });
    });

    display(Plot.plot({
      title: "The Mandelbrot Set",
      width: 500,
      height: 500,
      x: { axis: null },
      y: { axis: null },
      color: { scheme: "viridis", legend: true },
      marks: [
    Plot.raster(mbPlotData, { x: "x", y: "y", fill: "value" })
      ]
    }));
  </script>
  <script id="38" type="text/markdown">
    By zooming the plot, you can find unexplored regions. Let's create a zoom sequence:
  </script>
  <script id="39" type="module">
    // Create zoomed Mandelbrot views
    const mbRanges = [
      { xMin: -2.0, xMax: 1.0, yMin: -1.5, yMax: 1.5 },
      { xMin: -1.5, xMax: -1.0, yMin: 0, yMax: 0.5 },
      { xMin: -1.2, xMax: -1.1, yMin: 0.2, yMax: 0.3 },
      { xMin: -1.150, xMax: -1.145, yMin: 0.275, yMax: 0.280 }
    ];

    const mbZoomPlots = mbRanges.map(({ xMin, xMax, yMin, yMax }, i) => {
      const zoomMb = new jm.generative.fractals.Mandelbrot({
    width: 300,
    height: 300,
    xMin, xMax, yMin, yMax,
    maxIterations: 500
      });

      const zoomData = zoomMb.generate();
      const zoomPlotData = [];
      zoomData.forEach((row, y) => {
    row.forEach((value, x) => {
      zoomPlotData.push({ x, y, value });
    });
      });

      return html`<div style="display: inline-block; margin: 10px;">
    <div style="text-align: center; font-weight: bold; margin-bottom: 5px;">Zoom ${i + 1}</div>
    ${Plot.plot({
      width: 250,
      height: 250,
      x: { axis: null },
      y: { axis: null },
      color: { scheme: "viridis" },
      marks: [
        Plot.raster(zoomPlotData, { x: "x", y: "y", fill: "value" })
      ]
    })}
      </div>`;
    });

    display(html`<div style="display: flex; flex-wrap: wrap; justify-content: center;">${mbZoomPlots}</div>`);
  </script>
  <script id="40" type="text/markdown">
    By scanning the Mandelbrot matrix to extract the numbers (horizontally, vertically or diagonally), you can generate a sequence of integers. The smaller value used for length pixelates the Mandelbrot plot to create a smaller matrix, since we need fewer values for a musical sequence.
  </script>
  <script id="41" type="module" pinned="">
    // Create low-resolution Mandelbrot for music generation
    const mbLength = 20;
    const mbMusic = new jm.generative.fractals.Mandelbrot({
      width: mbLength,
      height: mbLength,
      xMin: -1.150,
      xMax: -1.145,
      yMin: 0.275,
      yMax: 0.280,
      maxIterations: 100
    });

    // Extract diagonal sequence using the built-in method
    const mbSequence = mbMusic.extractSequence('diagonal');

    display("Mandelbrot sequence: " + mbSequence.join(", "));

    // Plot the sequence
    const mbSeqPlotData = mbSequence.map((value, i) => ({ step: i, value }));

    display(Plot.plot({
      title: "Mandelbrot diagonal sequence",
      width: 600,
      height: 200,
      marks: [
    Plot.line(mbSeqPlotData, { x: "step", y: "value", stroke: "#1f77b4" }),
    Plot.dot(mbSeqPlotData, { x: "step", y: "value", fill: "#1f77b4" }),
    Plot.text(mbSeqPlotData, {
      x: "step",
      y: "value",
      text: d => d.value,
      dy: -10
    })
      ]
    }));
  </script>
  <script id="42" type="text/markdown">
    These numbers can be set as MIDI pitches, indices on scales, etc. If you need a scale, make sure the indices are included in the scale. We can use the built-in `mapToScale` method to convert the Mandelbrot values to pitches.
  </script>
  <script id="43" type="module" pinned="">
    // Create a G major scale spanning 2 octaves
    const gMajorScale = new jm.theory.harmony.Scale({ tonic: 'G', mode: 'major' });
    const gMajorPitches = gMajorScale.generate({ start: 'G3', length: 15 }); // 2 octaves + 1 note

    display("G major scale pitches: " + gMajorPitches);

    // Map Mandelbrot sequence to the G major scale pitches
    const mbPitches = mbSequence.map(value => {
      const normalized = (value - Math.min(...mbSequence)) / (Math.max(...mbSequence) - Math.min(...mbSequence));
      const index = Math.floor(normalized * (gMajorPitches.length - 1));
      return gMajorPitches[index];
    });

    const mbNotes = jm.theory.rhythm.beatcycle(
      mbPitches,
      [0.5, 0.5, 1, 2, 1]
    );

    const mbPiece = {
      title: "Mandelbrot Melody",
      tempo: 120,
      tracks: [{ notes: mbNotes, synth: 0 }]
    };

    display(await jm.score(mbPiece, { verovio }));
    display(await jm.play(mbPiece, { Tone }));
  </script>
  <script id="44" type="text/markdown">
    ## Logistic map

    The logistic map comes from the logistic growth equation, which in turn comes from the concept of population growth. Disregarding limitations from the environment, a population üêá of a reproducing species will grow at a certain *r* rate.

    $$
    üêá_{t+1} = r \times üêá_t
    $$

    That means that population *x* at the next step depends on population *x* at the current step times a growth rate, expressed in proportion of the population per step.
  </script>
  <script id="45" type="module">
    // Simple exponential growth
    const simpleGrowth = (x, r) => r * x;

    const initialPop = 100;
    const generations = 10;
    const growthRate = 2;

    const population = [initialPop];
    for (let i = 0; i < generations; i++) {
      population.push(simpleGrowth(population[i], growthRate));
    }

    const popData = population.map((pop, gen) => ({ generation: gen, population: pop }));

    display(Plot.plot({
      title: "Simple exponential growth (r=2)",
      height: 300,
      y: { label: "Population" },
      x: { label: "Generation" },
      marks: [
    Plot.line(popData, { x: "generation", y: "population", stroke: "#1f77b4" }),
    Plot.dot(popData, { x: "generation", y: "population", fill: "#1f77b4" })
      ]
    }));
  </script>
  <script id="46" type="text/markdown">
    The growth is exponential. The more the population, the more it reproduces. But populations never grow to infinite. There are always limits to population growth. We might want to decrease the growth rate over time. Or, a better way to think of it would be to decrease the growth rate according to the population: the more the population, the less the growth rate. Let's call it the limit of the environment *limit*. This is where the logistic equation is useful.

    $$
    üêá_{t+1} = r \times üêá_t \times \frac{(limit - üêá_t)}{limit}
    $$

    When üêá_t comes close to the *limit*, the term $\frac{(limit - üêá_t)}{limit}$ comes close to zero.
  </script>
  <script id="47" type="module">
    // Logistic growth
    const logisticGrowth = (x, r, limit) => r * x * (limit - x) / limit;

    const logisticPop = [initialPop];
    const limit = 5000;
    const logisticRate = 2;

    for (let i = 0; i < generations; i++) {
      logisticPop.push(logisticGrowth(logisticPop[i], logisticRate, limit));
    }

    const logisticData = logisticPop.map((pop, gen) => ({ generation: gen, population: pop }));

    display(Plot.plot({
      title: `Logistic growth (r=${logisticRate}, limit=${limit})`,
      height: 300,
      y: { label: "Population" },
      x: { label: "Generation" },
      marks: [
    Plot.line(logisticData, { x: "generation", y: "population", stroke: "#ff7f0e" }),
    Plot.dot(logisticData, { x: "generation", y: "population", fill: "#ff7f0e" })
      ]
    }));
  </script>
  <script id="48" type="text/markdown">
    You might have remarked that the population never reaches 5000, but only half of it. That's because the growth rate is decreased so much that population can't reach the maximum allowed. Let's see what happens with different growth rates.
  </script>
  <script id="49" type="module">
    // Compare different growth rates
    const growthRates = [2, 2.5, 3, 3.25];
    const longGenerations = 50;

    const allPopulations = growthRates.map(r => {
      const pop = [initialPop];
      for (let i = 0; i < longGenerations; i++) {
    pop.push(logisticGrowth(pop[i], r, limit));
      }
      return { rate: r, population: pop };
    });

    const compareData = allPopulations.flatMap(({ rate, population }) =>
      population.map((pop, gen) => ({
    generation: gen,
    population: pop,
    rate: `r=${rate}`
      }))
    );

    display(Plot.plot({
      title: "Logistic growth with different rates",
      height: 400,
      color: { legend: true },
      y: { label: "Population" },
      x: { label: "Generation" },
      marks: [
    Plot.line(compareData, { x: "generation", y: "population", stroke: "rate" })
      ]
    }));
  </script>
  <script id="50" type="text/markdown">
    When growth rate increases, an oscillating convergence to a stabilized value occurs, and this value depends on the growth rate. If we focus our interest on this stabilized value depending on growth rates, we get a very intriguing pattern - the logistic map bifurcation diagram.
  </script>
  <script id="51" type="module" pinned="">
    // Generate logistic map bifurcation diagram using the built-in method
    const lm = new jm.generative.fractals.LogisticMap({
      r: 3.5,
      x0: 0.5,
      iterations: 1000,
      skipTransient: 100
    });

    const lmBifurcation = lm.bifurcationDiagram(2.5, 4.0, 1000);

    // Format data for plotting
    const lmData = lmBifurcation.r.map((r, i) => ({
      r: r,
      value: lmBifurcation.x[i]
    }));
  </script>
  <script id="52" type="text/markdown">
    Let's visualize the famous bifurcation diagram:
  </script>
  <script id="53" type="module">
    // Plot the bifurcation diagram
    display(Plot.plot({
      title: "Logistic Map Bifurcation Diagram",
      width: 700,
      height: 400,
      x: { label: "Growth rate (r)" },
      y: { label: "Population" },
      marks: [
    Plot.dot(lmData, {
      x: "r",
      y: "value",
      r: 0.5,
      fill: "black",
      opacity: 0.3
    })
      ]
    }));
  </script>
  <script id="54" type="text/markdown">
    An explanation of this behaviour can be found on the Veritasium YouTube channel.

    <iframe width="560" height="315" src="https://www.youtube.com/embed/ovJcsL7vyrk?si=EQoJddVSfTCDMeox" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>

    The logistic map can be used to create notes. Here, we generate a sequence for musical use.
  </script>
  <script id="55" type="module" pinned="">
    // Generate musical sequence from logistic map
    const lmMusic = new jm.generative.fractals.LogisticMap({
      r: 3.8,
      x0: 0.5,
      iterations: 20,
      skipTransient: 100
    });

    const lmValues = lmMusic.generate();

    display("Logistic map values: " + lmValues.slice(0, 10).join(", ") + "...");

    // Plot the sequence
    const lmSeqData = lmValues.map((value, i) => ({ step: i, value }));

    display(Plot.plot({
      title: "Logistic map sequence for music",
      width: 600,
      height: 200,
      marks: [
    Plot.line(lmSeqData, { x: "step", y: "value", stroke: "#2ca02c" }),
    Plot.dot(lmSeqData, { x: "step", y: "value", fill: "#2ca02c" })
      ]
    }));
  </script>
  <script id="56" type="text/markdown">
    Map these values to a scale and create music:
  </script>
  <script id="57" type="module" pinned="">
    // Map to G major scale using the built-in method
    const lmPitches = lmMusic.mapToScale(lmValues, gMajorScale, 2);

    const lmNotes = jm.theory.rhythm.beatcycle(
      lmPitches,
      [0.5, 0.5, 1, 2, 1]
    );

    const lmPiece = {
      title: "Logistic Growth",
      tempo: 120,
      tracks: [{ notes: lmNotes, synth: 0 }]
    };

    display(await jm.score(lmPiece, { verovio }));
    display(await jm.play(lmPiece, { Tone }));
  </script>
  <script id="58" type="text/markdown">
    The logistic map creates interesting melodic patterns that have an underlying mathematical structure while still feeling organic and musical. The chaotic regions of the bifurcation diagram produce more unpredictable melodies, while the stable regions create more repetitive patterns.
  </script>
</notebook>
