<!doctype html>
<notebook theme="air">
  <title>8. Genetic Algorithms</title>
  <script id="0" type="text/markdown">
    # 8. Genetic Algorithms

    Genetic algorithms mimic natural selection and genetics to evolve solutions to problems over successive generations. Suppose we have a sequence of musical objects, described as:

    ```
    [ğŸŸ¨, ğŸŸ¨, ğŸŸ¨, ğŸŸ¨, ğŸŸ¨, ğŸŸ¨, ğŸŸ¨, ğŸŸ¨, ğŸŸ¨, ğŸŸ¨, ğŸŸ¨, ğŸŸ¨, ğŸŸ¨, ğŸŸ¨, ğŸŸ¨, ğŸŸ¨]
    ```

    We can clone it to obtain a population. But as in life, cloning is not perfect and mutations can occur.

    ```
    [
        [ğŸŸ¨, ğŸŸ¨, ğŸŸ¨, ğŸŸ¨, ğŸŸ¨, ğŸŸ¨, ğŸŸ¨, ğŸŸ¨, ğŸŸ¨, ğŸŸ¨, ğŸŸ¨, ğŸŸ¦, ğŸŸ¨, ğŸŸ¨, ğŸŸ¨, ğŸŸ¨],
        [ğŸŸ¨, ğŸŸ¨, ğŸŸ¨, ğŸŸ¨, ğŸŸ¨, ğŸŸ¨, ğŸŸ¨, ğŸŸ¨, ğŸŸ¨, ğŸŸ¨, ğŸŸ¨, ğŸŸ¨, ğŸŸ¨, ğŸŸ¨, ğŸŸ¨, ğŸŸ¨],
        [ğŸŸ¨, ğŸŸ¨, ğŸŸ¨, ğŸŸ¨, ğŸŸ¦, ğŸŸ¨, ğŸŸ¨, ğŸŸ¨, ğŸŸ¨, ğŸŸ¨, ğŸŸ¨, ğŸŸ¨, ğŸŸ¨, ğŸŸ¨, ğŸŸ¨, ğŸŸ¨],
        [ğŸŸ¨, ğŸŸ¨, ğŸŸ¥, ğŸŸ¨, ğŸŸ¨, ğŸŸ¨, ğŸŸ¨, ğŸŸ¨, ğŸŸ¨, ğŸŸ¦, ğŸŸ¨, ğŸŸ¨, ğŸŸ¨, ğŸŸ¨, ğŸŸ¨, ğŸŸ¨],
        [ğŸŸ¨, ğŸŸ¨, ğŸŸ¨, ğŸŸ¨, ğŸŸ¨, ğŸŸ¨, ğŸŸ¨, ğŸŸ¨, ğŸŸ¨, ğŸŸ¨, ğŸŸ¨, ğŸŸ¨, ğŸŸ¨, ğŸŸ¨, ğŸŸ¨, ğŸŸ¨]
    ]
    ```

    These mutations could benefit a sequence, or not. We need to quantify the benefit/detriment acquired after mutation.

    ```
    [
        [ğŸŸ¨, ğŸŸ¨, ğŸŸ¨, ğŸŸ¨, ğŸŸ¨, ğŸŸ¨, ğŸŸ¨, ğŸŸ¨, ğŸŸ¨, ğŸŸ¨, ğŸŸ¨, ğŸŸ¦, ğŸŸ¨, ğŸŸ¨, ğŸŸ¨, ğŸŸ¨], : score 58
        [ğŸŸ¨, ğŸŸ¨, ğŸŸ¨, ğŸŸ¨, ğŸŸ¦, ğŸŸ¨, ğŸŸ¨, ğŸŸ¨, ğŸŸ¨, ğŸŸ¨, ğŸŸ¨, ğŸŸ¨, ğŸŸ¨, ğŸŸ¨, ğŸŸ¨, ğŸŸ¨], : score 56
        [ğŸŸ¨, ğŸŸ¨, ğŸŸ¨, ğŸŸ¨, ğŸŸ¨, ğŸŸ¨, ğŸŸ¨, ğŸŸ¨, ğŸŸ¨, ğŸŸ¨, ğŸŸ¨, ğŸŸ¨, ğŸŸ¨, ğŸŸ¨, ğŸŸ¨, ğŸŸ¨], : score 50
        [ğŸŸ¨, ğŸŸ¨, ğŸŸ¨, ğŸŸ¨, ğŸŸ¨, ğŸŸ¨, ğŸŸ¨, ğŸŸ¨, ğŸŸ¨, ğŸŸ¨, ğŸŸ¨, ğŸŸ¨, ğŸŸ¨, ğŸŸ¨, ğŸŸ¨, ğŸŸ¨], : score 50
        [ğŸŸ¨, ğŸŸ¨, ğŸŸ¥, ğŸŸ¨, ğŸŸ¨, ğŸŸ¨, ğŸŸ¨, ğŸŸ¨, ğŸŸ¨, ğŸŸ¦, ğŸŸ¨, ğŸŸ¨, ğŸŸ¨, ğŸŸ¨, ğŸŸ¨, ğŸŸ¨]  : score 34
    ]
    ```

    We can breed together the best ones (let's say the two best ones who survived) to create children. Children can have the traits of a parent or another, and also can contain mutations.

    ```
    [
        [ğŸŸ©, ğŸŸ¨, ğŸŸ¨, ğŸŸ¨, ğŸŸ¨, ğŸŸ¨, ğŸŸ¥, ğŸŸ¨, ğŸŸ¨, ğŸŸ¨, ğŸŸ¨, ğŸŸ¦, ğŸŸ¨, ğŸŸ¨, ğŸŸ¨, ğŸŸ¨], : score 67
        [ğŸŸ¨, ğŸŸ©, ğŸŸ¨, ğŸŸ¨, ğŸŸ¨, ğŸŸ¨, ğŸŸ¨, ğŸŸ¨, ğŸŸ¨, ğŸŸ¦, ğŸŸ¨, ğŸŸ¨, ğŸŸ¨, ğŸŸ©, ğŸŸ¨, ğŸŸ¨]  : score 62
        [ğŸŸ¨, ğŸŸ¨, ğŸŸ¨, ğŸŸ¨, ğŸŸ¦, ğŸŸ¨, ğŸŸ¨, ğŸŸ¨, ğŸŸ¨, ğŸŸ¨, ğŸŸ¨, ğŸŸ¦, ğŸŸ¨, ğŸŸ¨, ğŸŸ¨, ğŸŸ¨], : score 61
        [ğŸŸ¨, ğŸŸ¨, ğŸŸ¨, ğŸŸ¨, ğŸŸ¨, ğŸŸ¨, ğŸŸ¨, ğŸŸ¨, ğŸŸ¨, ğŸŸ¨, ğŸŸ¨, ğŸŸ¨, ğŸŸ¨, ğŸŸ¨, ğŸŸ¨, ğŸŸ¨], : score 50
        [ğŸŸ¨, ğŸŸ¨, ğŸŸ¨, ğŸŸ¨, ğŸŸ¦, ğŸŸ©, ğŸŸ¨, ğŸŸ¨, ğŸŸ¨, ğŸŸ¨, ğŸŸ¨, ğŸŸ¨, ğŸŸ¨, ğŸŸ¨, ğŸŸ¨, ğŸŸ¨], : score 46
    ]
    ```

    And so on. Given an initial population, scoring criteria, number of best mates, mutation rates and number of generations, we can "evolve" a piece of music.
  </script>
  <script id="1" type="module" pinned="">
    import jm from "../src/index.js";
    import * as Tone from "npm:tone";
    import verovio from "npm:verovio@4.3.1/wasm";
    import * as Plot from "npm:@observablehq/plot@0.6";
  </script>
  <script id="2" type="text/markdown">
    ## The `Darwin` class

    The `Darwin` class in the `genetic` module takes care of the evolution process, while the `MusicalIndex` class in the `analysis` module takes care of scoring.

    ### 1. Population Initialization

    The evolutionary journey begins with the creation of an initial population. In the `Darwin` class, this population is a list of notes, or track, complying to jmon/algo's notation, where each note is a `[pitch, duration, time]` array. This population acts as the gene pool from which new musical ideas will be generated and evolved. The diversity within this initial population is crucial as it lays the foundation for genetic variation and the potential for innovative musical creations.

    Twinkle, twinkle little star in C-major can be used as our primordial soup.
  </script>
  <script id="3" type="module" pinned="">
    const initialPhrases = [
      [
        [60, 1.0, 0.0],  // C (twin)
        [60, 1.0, 1.0],  // C (kle)
        [67, 1.0, 2.0],  // G (twin)
        [67, 1.0, 3.0],  // G (kle)
        [69, 1.0, 4.0],  // A (lit)
        [69, 1.0, 5.0],  // A (tle)
        [67, 2.0, 6.0],  // G (star)
        [65, 1.0, 8.0],  // F (how)
        [65, 1.0, 9.0],  // F (I)
        [64, 1.0, 10.0], // E (won)
        [64, 1.0, 11.0], // E (der)
        [62, 1.0, 12.0], // D (what)
        [62, 1.0, 13.0], // D (you)
        [60, 2.0, 14.0], // C (are)
      ]
    ];

    display("Initial phrase:");
    display(initialPhrases[0]);
  </script>
  <script id="4" type="text/markdown">
    ### 2. Fitness Evaluation

    Once the population is established, each member (musical phrase) undergoes a fitness evaluation. This is where the `MusicalIndex` class assesses how well each phrase meets predefined quantitative criteria based on a variety of metrics, including pitch diversity, rhythmic balance, and motif development. An overall score is computed as the weighted similarity to ideal scores defined as targets. This score determines the phrase's suitability and guides the selection process for the next generation. The higher the similarity score, the better the musical phrase aligns with the desired compositional goals.

    Let's examine the metrics for our initial phrase:
  </script>
  <script id="5" type="module">
    // Extract pitch and duration sequences
    const pInitial = initialPhrases[0].map(note => note[0]);
    const rInitial = initialPhrases[0].map(note => note[1]);

    // Create C major scale for dissonance calculation
    const cMajorScale = new jm.theory.harmony.Scale({ tonic: 'C', mode: 'major' });
    const cMajorPitches = cMajorScale.generate({ start: 'C0', length: 128 });

    // Calculate metrics
    const pitchIndex = new jm.analysis.MusicalIndex(pInitial);
    const rhythmIndex = new jm.analysis.MusicalIndex(rInitial);

    const giniPitchInitial = pitchIndex.gini();
    const giniRhythmInitial = rhythmIndex.gini();
    const balancePitchInitial = pitchIndex.balance();
    const balanceRhythmInitial = rhythmIndex.balance();
    const motifPitchInitial = pitchIndex.motif();
    const motifRhythmInitial = rhythmIndex.motif();
    const dissonanceInitial = pitchIndex.dissonance(cMajorPitches);
    const rhythmicInitial = rhythmIndex.rhythmic(4);
    const restInitial = pitchIndex.restProportion();

    const initialValues = [
      giniPitchInitial,
      giniRhythmInitial,
      balancePitchInitial,
      balanceRhythmInitial,
      motifPitchInitial,
      motifRhythmInitial,
      dissonanceInitial,
      rhythmicInitial,
      restInitial
    ];

    const categories = [
      "Gini pitch",
      "Gini rhythm",
      "Balance pitch",
      "Balance rhythm",
      "Motif pitch",
      "Motif rhythm",
      "Dissonance",
      "Rhythmic",
      "Rest"
    ];

    display(Plot.plot({
      title: "Initial phrase metrics",
      marginLeft: 120,
      x: { label: "Score", domain: [0, 1] },
      y: { label: null },
      marks: [
        Plot.barX(categories.map((cat, i) => ({ category: cat, value: initialValues[i] })), {
          x: "value",
          y: "category",
          fill: "steelblue"
        })
      ]
    }));
  </script>
  <script id="6" type="text/markdown">
    In the beginning, the population is composed of clones of the initial musical phrase. So the fitness score of each individual of the initial population should be equal. Until mutations happen.

    ### 3. Mutation

    Mutation introduces random changes to the musical phrases. In the Darwin class, this can involve altering the pitch, duration, or time of notes within a phrase - although in practice it is more convenient to consider the time as a consequence of following durations. The mutation rate determines the probability of these changes occurring and is a critical factor in maintaining genetic diversity within the population. By introducing new variations, mutation ensures that the evolutionary process does not stagnate and allows for the exploration of new musical territories.

    **API call.**

    ```js
    const mutationExample = demoDarwin.mutate(initialPhrases[0].map(note => [...note]));
    ```

    ### 4. Selection

    Selection is the process of choosing the fittest individuals from the population to carry forward to the next generation. The Darwin class employs a method where the top-performing musical phrases (based on their fitness scores) are selected. This mimics natural selection, where the most adapted individuals have a higher chance of survival and reproduction. The selected phrases ensure that the population's quality improves over generations, moving closer to the desired musical objectives.

    **API call.**

    ```js
    const selectedParents = demoDarwin.select(5);
    ```

    ### 5. Crossover

    Crossover, or recombination, is the process where genetic material is exchanged between the phrases of two random parents (who survived the selection process) to produce new offspring phrases. This is akin to mating in natural systems. In the context of the `Darwin` class, segments from two selected musical phrases are combined to create new phrases. This mixing of genetic information promotes diversity within the population and contributes to the development of innovative and complex musical compositions.

    **API call.**

    ```js
    const crossoverChild = demoDarwin.crossover(selectedParents[0], selectedParents[1]);
    ```

    ### 6. The Evolution Process

    The evolution process in the `Darwin` class encompasses the repeated application of mutation, selection, and crossover over multiple generations. With each generation, the population undergoes mutation and recombination, followed by the selection of the fittest individuals based on their adaptivity to the musical criteria. This cycle continues iteratively, with the population ideally becoming more refined and closer to the desired musical goals with each generation.

    **API call.**

    ```js
    const generationStats = demoDarwin.evolve(5);
    ```

    The following cell executes these snippets on a lightweight `demoDarwin` instance so you can compare the actual arrays that come out of each method before we launch the longer evolution run.

    With the groundwork laid, we proceed to the core of our exploration: the application of the Darwin class to evolve our musical phrases.
  </script>
  <script id="6a" type="module">
    const demoDarwin = new jm.generative.genetic.Darwin({
      initialPhrases: initialPhrases,
      mutationRate: 0.05,
      populationSize: 40,
      scale: cMajorPitches,
      measureLength: 4,
      timeResolution: [0.25, 4],
      seed: 7
    });

    globalThis.demoDarwin = demoDarwin;

    const mutationExample = demoDarwin.mutate(initialPhrases[0].map(note => [...note]));
    const selectedParents = demoDarwin.select(5);
    const crossoverChild = demoDarwin.crossover(selectedParents[0], selectedParents[1]);
    const generationStats = demoDarwin.evolve(5);

    display({
      mutationPreview: mutationExample.slice(0, 4),
      parentFitness: selectedParents.slice(0, 3).map(phrase => demoDarwin.fitness(phrase)),
      crossoverPreview: crossoverChild.slice(0, 4),
      generationStats
    });
  </script>
  <script id="7" type="module" pinned="">
    // Configure weights and targets
    const weights = {
      gini: [1.0, 1.0, 0.0],      // [pitch, duration, offset]
      balance: [1.0, 1.0, 0.0],
      motif: [10.0, 1.0, 0.0],
      dissonance: [1.0, 0.0, 0.0],
      rhythmic: [0, 10.0, 0],
      rest: [1.0, 0.0, 0.0]
    };

    const targets = {
      gini: [0.2, 0.5, 0.0],
      balance: [0.5, 0.1, 0.0],
      motif: [0.8, 0.5, 0.0],
      dissonance: [0.05, 0.0, 0.0],
      rhythmic: [0.0, 1.0, 0.0],
      rest: [0.0, 0.0, 0.0]
    };

    // Create the evolver
    const evolver = new jm.generative.genetic.Darwin({
      initialPhrases: initialPhrases,
      mutationRate: 0.05,
      populationSize: 200,
      scale: cMajorPitches,
      measureLength: 4,
      timeResolution: [0.25, 4],
      weights: weights,
      targets: targets,
      seed: 111
    });

    display("Darwin evolver created with population size: " + evolver.populationSize);
  </script>
  <script id="8" type="text/markdown">
    The Darwin class encapsulates the genetic algorithm, facilitating the evolution of our initial musical phrases through processes of mutation, selection, and crossover. The parameters such as `mutationRate`, `populationSize`, and `timeResolution` define the environment and rules under which our musical compositions will evolve.

    ### Fitness weights & targets at a glance

    | Metric | What it measures | Default weight (pitch / duration / offset) | Typical target range |
    | --- | --- | --- | --- |
    | `gini` | Evenness of pitch or duration distribution | `1.0 / 1.0 / 0.0` | Pitch `0.1â€“0.3`, duration `0.4â€“0.6` |
    | `balance` | Center of gravity (e.g., around middle C) | `1.0 / 1.0 / 0.0` | Pitch `0.45â€“0.55`, duration `0.1â€“0.2` |
    | `motif` | Repetition strength | `10.0 / 1.0 / 0.0` | `0.7â€“1.0` |
    | `dissonance` | Scale conformity | `1.0 / 0.0 / 0.0` | `< 0.1` for diatonic phrases |
    | `rhythmic` | Grid alignment of durations | `0.0 / 10.0 / 0.0` | `0.8â€“1.0` |
    | `rest` | Silence proportion | `1.0 / 0.0 / 0.0` | `0.0â€“0.05` |

    Use the weights to emphasize the columns that matter for your piece (many workflows keep offset weights at zero). Targets act as magnets: the closer a phrase gets to them, the higher the fitness.

    **Tuning tips**

    - `mutationRate`: keep it between `0.02` and `0.15`; higher values create noisy phrases, lower values risk stagnation.
    - `populationSize`: `40â€“250` is practical. Larger populations explore more but take longer to evaluate.
    - `timeResolution`: pair it with `measureLength` so durations snap to your intended rhythmic grid.
    - `k` argument in `evolve(k)`: select 10â€“25 parents for melodic material; increase `k` when you need stronger selection pressure.
    - `mutationProbabilities`: override the defaults when you want to bias mutations toward a register, rhythm family, or rest density.

    This evolution process is run in a loop. It's the heart of the genetic algorithm, where each cycle represents a generational shift towards optimal musical phrases based on the weights and targets. After some iterations, the musical piece should stop its evolution, since it's no longer relying on finding good parents, but rather relying on random mutations to improve.
  </script>
  <script id="9" type="module" pinned="">
    // Run evolution
    for (let i = 0; i < 100; i++) {
      evolver.evolve(10); // k=10 parents selected each generation
    }

    display("Evolution complete! Ran " + evolver.generationCount + " generations");
  </script>
  <script id="10" type="text/markdown">
    We can plot the similarity score to make sure it indeed evolved:
  </script>
  <script id="11" type="module">
    // Plot evolution of fitness scores
    const scoreData = evolver.bestScores.map((score, generation) => ({
      generation,
      fitness: score
    }));

    display(Plot.plot({
      title: "Fitness evolution over generations",
      width: 700,
      height: 400,
      x: { label: "Generation" },
      y: { label: "Fitness score" },
      marks: [
        Plot.line(scoreData, { x: "generation", y: "fitness", stroke: "steelblue" }),
        Plot.dot(scoreData, { x: "generation", y: "fitness", fill: "steelblue", r: 2 })
      ]
    }));
  </script>
  <script id="12" type="text/markdown">
    Upon the conclusion of the evolutionary cycles, it's crucial to evaluate the transformed musical material. Let's compare the initial and final metrics:
  </script>
  <script id="13" type="module">
    // Get final phrase
    const finalPhrase = evolver.getBestIndividual();
    const pFinal = finalPhrase.map(note => note[0]);
    const rFinal = finalPhrase.map(note => note[1]);

    // Calculate final metrics
    const pitchIndexFinal = new jm.analysis.MusicalIndex(pFinal);
    const rhythmIndexFinal = new jm.analysis.MusicalIndex(rFinal);

    const giniPitchFinal = pitchIndexFinal.gini();
    const giniRhythmFinal = rhythmIndexFinal.gini();
    const balancePitchFinal = pitchIndexFinal.balance();
    const balanceRhythmFinal = rhythmIndexFinal.balance();
    const motifPitchFinal = pitchIndexFinal.motif();
    const motifRhythmFinal = rhythmIndexFinal.motif();
    const dissonanceFinal = pitchIndexFinal.dissonance(cMajorPitches);
    const rhythmicFinal = rhythmIndexFinal.rhythmic(4);
    const restFinal = pitchIndexFinal.restProportion();

    const finalValues = [
      giniPitchFinal,
      giniRhythmFinal,
      balancePitchFinal,
      balanceRhythmFinal,
      motifPitchFinal,
      motifRhythmFinal,
      dissonanceFinal,
      rhythmicFinal,
      restFinal
    ];

    const targetValues = [
      targets.gini[0],
      targets.gini[1],
      targets.balance[0],
      targets.balance[1],
      targets.motif[0],
      targets.motif[1],
      targets.dissonance[0],
      targets.rhythmic[1],
      targets.rest[0]
    ];

    // Create comparison data
    const comparisonData = categories.flatMap((cat, i) => [
      { category: cat, type: "Initial", value: initialValues[i] },
      { category: cat, type: "Final", value: finalValues[i] },
      { category: cat, type: "Target", value: targetValues[i] }
    ]);

    display(Plot.plot({
      title: "Metrics comparison: Initial vs Final vs Target",
      marginLeft: 120,
      width: 800,
      height: 500,
      x: { label: "Score", domain: [0, 1] },
      fy: { label: null },
      color: { legend: true },
      marks: [
        Plot.barX(comparisonData, {
          x: "value",
          fy: "category",
          fill: "type",
          sort: { fy: null }
        })
      ]
    }));
  </script>
  <script id="14" type="text/markdown">
    Although some metrics might diverge from targets, overall the evolution has moved the musical phrase toward the desired characteristics. Here is our final piece!
  </script>
  <script id="15" type="module" pinned="">
    // Quantize the notes (working with tuple format [pitch, duration, time])
    const quantizedTuples = jm.utils.quantizeNotes({
      notes: finalPhrase,
      measureLength: 4,
      timeResolution: 0.125
    });

    // Convert from [pitch, duration, time] to {pitch, duration, time}
    const galapagosNotes = quantizedTuples.map(note => ({
      pitch: note[0],
      duration: note[1],
      time: note[2]
    }));

    const galapagosStars = {
      title: "Galapagos Stars - Evolved Melody",
      tempo: 120,
      tracks: [{
        notes: galapagosNotes,
        synth: 0
      }]
    };

    //display(await jm.score(galapagosStars, { verovio }));
    display(await jm.play(galapagosStars, { Tone }));
  </script>
  <script id="16" type="text/markdown">
    The result might seem simple, but seeing how pitches evolved grasps the underlying process. Let's visualize the evolution of pitches across all generations:
  </script>
  <script id="17" type="module">
    // Plot pitch evolution across generations
    const allPitchLines = evolver.bestIndividuals.flatMap((individual, generation) =>
      individual.map((note, index) => ({
        generation,
        position: index,
        pitch: note[0]
      }))
    );

    display(Plot.plot({
      title: "Pitch evolution across generations",
      width: 800,
      height: 400,
      x: { label: "Note position in phrase" },
      y: { label: "MIDI pitch" },
      marks: [
        Plot.line(allPitchLines, {
          x: "position",
          y: "pitch",
          z: "generation",
          stroke: "black",
          opacity: 0.1
        })
      ]
    }));
  </script>
  <script id="18" type="text/markdown">
    Through this structured evolutionary process, the `Darwin` class facilitates the generation of new and innovative musical compositions that evolve over time, guided by the principles of genetic variation, selection, and inheritance. The end result is a dynamic exploration of musical possibilities that extends beyond traditional composition techniques.

    ## Advanced usage

    You can customize the mutation probabilities to control how evolution explores the musical space:
  </script>
  <script id="19" type="module">
    // Example with custom mutation probabilities
    const customMutationProbs = {
      pitch: () => {
        // Favor pitches in a specific range (e.g., middle register)
        const base = 55 + Math.floor(Math.random() * 24); // G3 to G5
        return Math.max(0, Math.min(127, base));
      },
      duration: () => {
        // Favor shorter note values
        const choices = [0.25, 0.5, 1, 2];
        const weights = [4, 3, 2, 1]; // Favor shorter durations
        const totalWeight = weights.reduce((a, b) => a + b, 0);
        let random = Math.random() * totalWeight;
        for (let i = 0; i < choices.length; i++) {
          random -= weights[i];
          if (random <= 0) return choices[i];
        }
        return choices[choices.length - 1];
      },
      rest: () => {
        // Slightly higher chance of rests
        return Math.random() < 0.05 ? null : 1;
      }
    };

    const customEvolver = new jm.generative.genetic.Darwin({
      initialPhrases: initialPhrases,
      mutationRate: 0.08,
      populationSize: 100,
      mutationProbabilities: customMutationProbs,
      scale: cMajorPitches,
      measureLength: 4,
      timeResolution: [0.25, 2],
      seed: 42
    });

    display("Created custom evolver with specialized mutation probabilities");
  </script>
  <script id="20" type="text/markdown">
    You can also track population statistics to understand the diversity and convergence of your evolution:
  </script>
  <script id="21" type="module">
    // Run a few generations and track stats
    const populationStats = [];

    for (let i = 0; i < 50; i++) {
      customEvolver.evolve(10);
      const stats = customEvolver.getPopulationStats();
      populationStats.push(stats);
    }

    // Plot fitness diversity over time
    const diversityData = populationStats.map((stats, i) => ({
      generation: i,
      mean: stats.meanFitness,
      min: stats.minFitness,
      max: stats.maxFitness,
      stdDev: stats.standardDeviation
    }));

    display(Plot.plot({
      title: "Population fitness diversity",
      width: 700,
      height: 400,
      x: { label: "Generation" },
      y: { label: "Fitness" },
      marks: [
        Plot.areaY(diversityData, {
          x: "generation",
          y1: d => d.mean - d.stdDev,
          y2: d => d.mean + d.stdDev,
          fill: "lightblue",
          opacity: 0.3
        }),
        Plot.line(diversityData, { x: "generation", y: "mean", stroke: "blue" }),
        Plot.line(diversityData, { x: "generation", y: "max", stroke: "green", strokeDasharray: "4,2" }),
        Plot.line(diversityData, { x: "generation", y: "min", stroke: "red", strokeDasharray: "4,2" })
      ]
    }));
  </script>
  <script id="22" type="text/markdown">
    Genetic algorithms offer a powerful approach to algorithmic composition, allowing you to define high-level musical goals and let evolution discover creative solutions. By adjusting weights, targets, and mutation parameters, you can guide the evolution toward different musical aesthetics while maintaining an element of surprise and innovation.
  </script>
  <script id="23" type="text/markdown">
    ## Random walk + Darwin: a full-pipeline example

    To showcase how jmon/algo modules complement one another, let's recycle the melodic wanderings from the random-walk chapter (06) and hand the resulting phrase to `Darwin`. The walk provides a spontaneous idea; the genetic stage then nudges it toward better pitch balance and motif strength.
  </script>
  <script id="24" type="module">
    const walk = new jm.generative.walks.RandomWalk({
      length: 16,
      stepSize: 2,
      bounds: [55, 75],
      attractorStrength: 0.05
    });

    walk.generate([60]);

    const walkPitches = walk.mapToScale(0, [0, 2, 4, 5, 7, 9, 11], 2);
    const walkDurations = walk.mapToRhythm(0, [0.5, 0.5, 1, 1.5]);
    const phraseLength = Math.min(walkPitches.length, walkDurations.length);

    const walkPhrase = [];
    let walkTime = 0;
    for (let i = 0; i < phraseLength; i++) {
      const duration = walkDurations[i];
      walkPhrase.push([walkPitches[i], duration, walkTime]);
      walkTime += duration;
    }

    const walkPitchIndex = new jm.analysis.MusicalIndex(walkPhrase.map(note => note[0]));
    const walkInitialMetrics = {
      balance: walkPitchIndex.balance(),
      motif: walkPitchIndex.motif()
    };

    const walkWeights = {
      gini: [0.5, 0.5, 0.0],
      balance: [2.5, 0.5, 0.0],
      motif: [12.0, 1.0, 0.0],
      dissonance: [0.5, 0.0, 0.0],
      rhythmic: [0.0, 6.0, 0.0],
      rest: [0.2, 0.0, 0.0]
    };

    const walkTargets = {
      gini: [0.25, 0.5, 0.0],
      balance: [0.5, 0.1, 0.0],
      motif: [0.9, 0.6, 0.0],
      dissonance: [0.05, 0.0, 0.0],
      rhythmic: [0.0, 1.0, 0.0],
      rest: [0.0, 0.0, 0.0]
    };

    const walkEvolver = new jm.generative.genetic.Darwin({
      initialPhrases: [walkPhrase],
      mutationRate: 0.08,
      populationSize: 120,
      weights: walkWeights,
      targets: walkTargets,
      scale: cMajorPitches,
      measureLength: 4,
      timeResolution: [0.25, 2],
      seed: 2718
    });

    for (let i = 0; i < 60; i++) {
      walkEvolver.evolve(12);
    }

    const evolvedPhrase = walkEvolver.getBestIndividual();
    const evolvedPitchIndex = new jm.analysis.MusicalIndex(evolvedPhrase.map(note => note[0]));
    const walkFinalMetrics = {
      balance: evolvedPitchIndex.balance(),
      motif: evolvedPitchIndex.motif()
    };

    const walkComparisonData = [
      { metric: "Pitch balance", stage: "Random walk", value: walkInitialMetrics.balance },
      { metric: "Pitch balance", stage: "Darwin refined", value: walkFinalMetrics.balance },
      { metric: "Motif strength", stage: "Random walk", value: walkInitialMetrics.motif },
      { metric: "Motif strength", stage: "Darwin refined", value: walkFinalMetrics.motif }
    ];

    display({
      walkSeedPreview: walkPhrase.slice(0, 6),
      evolvedPreview: evolvedPhrase.slice(0, 6)
    });

    display(Plot.plot({
      title: "Random walk vs. Darwin refinement",
      width: 600,
      height: 320,
      x: { label: "Metric / stage" },
      y: { label: "Score", domain: [0, 1] },
      color: { legend: true },
      marks: [
        Plot.barY(walkComparisonData, {
          x: d => `${d.metric} - ${d.stage}`,
          y: "value",
          fill: "stage"
        })
      ]
    }));
  </script>
</notebook>
