<!doctype html>
<notebook>
  <title>5. Minimalism</title>
  
  <script type="text/markdown">
# 5. Minimalism

The `jmon/algo` package includes well-known minimalistic mathematical operations on notes to create no less rich musical scores. We will cover and merge two kinds of minimalistic operations: deterministic, where the outputs are consistently determined by the inputs, and stochastic, where we induce randomness. Of course, deterministic composition can be mixed with randomness. We would then refer to generative composition - generative art is *not* only affiliated to AI. In this section, I explain how to compose minimalistic, but rich music with `jmon/algo`.
  </script>

  <script type="module" pinned>
import jm from "../src/index.js";
import * as Tone from "npm:tone";
import * as ABCJS from "npm:abcjs";
  </script>

  <script type="text/markdown">
## Isorhythms

The isorhythm consists in mapping durations to pitches. The process can be done by zipping together lists of pitches and rhythms (like the two sides of a zipper), but the `isorhythm` function keeps zipping the sequence as long as the end of pitches and durations coincide. Then the timing is adjusted to durations.

### Showcase

Let's generate a simple solfege.
  </script>

  <script type="module" pinned>
const pitchesCmajor = new jm.theory.harmony.Scale({tonic: "C", mode: "major"}).generate({ start: 60, length: 8 });
const durationsSolfege = [1, 1, 1, 1, 1, 1, 1, 1];
const solfege_track = jm.theory.rhythm.isorhythm(pitchesCmajor, durationsSolfege);
const solfege_piece = { title:"Solfege", tempo: 120, tracks: [{ notes: solfege_track }] };
display(jm.score(solfege_piece, { ABCJS }));
  </script>

  <script type="text/markdown">
If the lengths are not factors to each other, the score will expand with interesting patterns.
  </script>

  <script type="module" pinned>
const durationsIso = [2, 1, 1, 2, 1, 1, 2, 1];
const isorhythm_track = jm.theory.rhythm.isorhythm(pitchesCmajor, durationsIso);
const isorhythm_piece = { title:"Isorhythm", tempo: 120, tracks: [{ notes: isorhythm_track }] };
display(jm.score(isorhythm_piece, { ABCJS }));
  </script>

  <script type="text/markdown">
### Composition

I use to name my tracks as `track1a_` for the first (`a`) part of track `1`, then the description of the object after the underscore `_`. This helps me to organize my composition. Because the length of the note list (6 items) differs from that of durations (10 items), and durations sum to 8 with the default time signature, each measure will contain the same durations, but with different notes, providing interesting evolving patterns.
  </script>

  <script type="module" pinned>
const track1a_pitches = [68, 64, 71, 69, 75, 73]; // pitches, 6 items in E major
const track1a_durations = [1, 0.5, 0.25, 0.5, 1, 0.75, 0.5, 0.5, 1, 2]; // durations, 10 items
const track1a = jm.theory.rhythm.isorhythm(track1a_pitches, track1a_durations);
display(jm.score({ title:"track1a", tempo: 120, tracks: [{ notes: track1a }] }, { ABCJS }));
  </script>

  <script type="text/markdown">
## Additive and subtractive processes

A forward additive process on [A, B, C, D] will take the first note, then the first and second, then first, second and third and so on as [A, A, B, A, B, C, A, B, C, D]. Two repetitions will expand the melody more slowly, as [A, A, A, B, A, B, A, B, C, A, B, C, A, B, C, D, A, B, C, D]. Instead of adding the notes gradually, a subtractive process removes them. A forward subtractive process with one repetition will go as [A, B, C, D, B, C, D, C, D, D].

### Showcase

To show what is an additive process, let's take the solfège. I will apply additive and subtractive processes, forward and backward on C4, D4, E4, F4, G4, A4, B4, C5. First, the **additive forward process** grows by iteratively adding the next note from the beginning.

```
    C4,
    C4, D4,
    C4, D4, E4,
    C4, D4, E4, F4,
    C4, D4, E4, F4, G4,
    C4, D4, E4, F4, G4, A4, 
    C4, D4, E4, F4, G4, A4, B4, 
    C4, D4, E4, F4, G4, A4, B4, C5
```

The additive process is applied on the track level.
  </script>

  <script type="module" pinned>
const afProcess = new jm.generative.minimalism.Process({
  operation: "additive",
  direction: "forward",
  repetition: 0
}).generate(solfege_track);
display(jm.score({title: "Additive forward", tracks: [{ notes: afProcess }] }, { ABCJS }));
  </script>

  <script type="text/markdown">
The **additive backward process** grows from the end of the melody and iteratively adds the previous one.

```
    C5,
    B4, C5,
    A4, B4, C5,
    G4, A4, B4, C5,
    F4, G4, A4, B4, C5,
    E4, F4, G4, A4, B4, C5,
    D4, E4, F4, G4, A4, B4, C5,
    C4, D4, E4, F4, G4, A4, B4, C5
```
  </script>

  <script type="module" pinned>
const abProcess = new jm.generative.minimalism.Process({
  operation: "additive",
  direction: "backward",
  repetition: 0
}).generate(solfege_track);
display(jm.score({title: "Additive backward", tracks: [{ notes: abProcess }] }, { ABCJS }));
  </script>

  <script type="text/markdown">
Subtractive processes inverse the triangles I presented. The **subtractive forward process** plays the whole melody, then iteratively removes the **first** note.

```
    C4, D4, E4, F4, G4, A4, B4, C5,
    D4, E4, F4, G4, A4, B4, C5,
    E4, F4, G4, A4, B4, C5,
    F4, G4, A4, B4, C5,
    G4, A4, B4, C5,
    A4, B4, C5,
    B4, C5,
    C5
```
  </script>

  <script type="module" pinned>
const sfProcess = new jm.generative.minimalism.Process({
  operation: "subtractive",
  direction: "forward",
  repetition: 0
}).generate(solfege_track);
display(jm.score({title: "Subtractive forward", tracks: [{ notes: sfProcess }] }, { ABCJS }));
  </script>

  <script type="text/markdown">
The **subtractive backward process** plays the whole melody, then iteratively removes the **last** note.

```
    C4, D4, E4, F4, G4, A4, B4, C5,
    C4, D4, E4, F4, G4, A4, B4,
    C4, D4, E4, F4, G4, A4,
    C4, D4, E4, F4, G4,
    C4, D4, E4, F4,
    C4, D4, E4,
    C4, D4,
    C4
```
  </script>

  <script type="module" pinned>
const sbProcess = new jm.generative.minimalism.Process({
  operation: "subtractive",
  direction: "backward",
  repetition: 0
}).generate(solfege_track);
display(jm.score({title: "Subtractive backward", tracks: [{ notes: sbProcess }] }, { ABCJS }));
  </script>

  <script type="text/markdown">
There are four other use cases involving inward and outward directions in additive and subtracting processes, as well as an option for repetitions, which are covered in the API of the minimalism module. While the outcome of additive and subtractive processes is predictable for simple melodies, complex melodies can expand or shrink to interesting patterns. Unless you have a precise mathematical framework in mind, my suggestion is to empirically try combinations of processes and arguments that sound good to your ears, then investigate what you are really doing with a solfège. However, if the initial melody is long, these processes can expand to very long pieces and become quite boring.

Let's try additive processes on our composition.

### Composition

I planned to append an additive and a subtractive process to track 1, in E major. Let's first create a melody.
  </script>

  <script type="module" pinned>
display(new jm.theory.harmony.Scale({tonic: "E", mode: "major"}).generate({start: 60, length: 24}));
const basePitches = [71, 64, 80, 73, 85, 83, 78, 63]; // 8 notes in E major
const baseDurations = [1.5, 0.25, 2.25, 1, 0.25, 0.25, 0.5, 2];
const track1b_a = jm.theory.rhythm.isorhythm(basePitches, baseDurations);
display(jm.score({ title:"track1b_a", tempo: 120, tracks: [{ notes: track1b_a }] }, { ABCJS }));
  </script>

  <script type="text/markdown">
I use an additive forward process and a subtractive backward process.
  </script>

  <script type="module" pinned>
// Generate additive forward process
const track1b_af = new jm.generative.minimalism.Process({
  operation: "additive",
  direction: "forward",
  repetition: 0
}).generate(track1b_a);

// Generate subtractive backward process
const track1b_sb = new jm.generative.minimalism.Process({
  operation: "subtractive",
  direction: "backward",
  repetition: 0
}).generate(track1b_a);

// Combine the processes
const track1b = jm.utils.chain(track1b_af, track1b_sb); 

display(await jm.play({ title:"track1b", tempo: 120, tracks: [{ notes: track1b }] }, { Tone }));
  </script>

  <script type="text/markdown">
It sounds incomplete, like a distress without conclusion. I need to conclude the piece like it began, but somewhat differently.

## Shuffling

Shuffling is moving around items in a list. It can be pitches, durations, lists of notes, etc. While shuffling durations will largely change the shape of the melody, shuffling pitches is a reboot of the same rhythmic pattern. Shuffling is the only stochastic (random) process I am going to use in this section.

### Showcase

I created three functions to shuffle. `seededRandom` is a snippet often used on the web to make sure that a random process in JavaScript always generates the same outcome. In fact it makes the code deterministic considering a seed number that can be fixed. `shuffleWithSeed` shuffles the array considering the seed. I use a seeded random function so that each time I run the random process, I obtain the exact same result.
  </script>

  <script type="module" pinned>
// Seeded random generator
const seededRandom = (seed) => () => (seed = (seed * 9301 + 49297) % 233280) / 233280;

// Fisher-Yates shuffle with seed
const shuffleWithSeed = (arr, seed) => {
  const rng = seededRandom(seed);
  const s = [...arr];
  for (let i = s.length - 1; i > 0; i--) {
    const j = Math.floor(rng() * (i + 1));
    [s[i], s[j]] = [s[j], s[i]];
  }
  return s;
};

// reset timing
const solfegeShuffled = jm.utils.recalculateTiming(
  shuffleWithSeed(solfege_track, 4698801)
);
display(jm.score({ title:"Shuffled solfege", tempo: 120, tracks: [{ notes: solfegeShuffled }] }, { ABCJS }));
  </script>

  <script type="text/markdown">
### Composition

I use shuffling here to give a sense of completion after the additive / subtractive processes, by randomly moving the notes of `track1a`. I changed the seed until I obtain something I like.
  </script>

  <script type="module" pinned>
const track1c = jm.utils.recalculateTiming(
  shuffleWithSeed(track1a, 9265927)
);
display(track1c);
  </script>

  <script type="text/markdown">
It still sounds monotone. A tintinnabuli might enrich the piece.

## Tintinnabuli

The tintinnabuli is a procedural music composition technique developed by the classical composer [Arvo Pärt](https://en.wikipedia.org/wiki/Arvo_P%C3%A4rt) to create spiritual, Christian sounds, but amenable to styles at the limit of your imagination. A tintinnabuli is made of two tracks: a melody we call the *m-voice*, and a counterpoint we call the *t-voice* (*t* for tintinnabuli), generated from the *m-voice*.

The *t-voice* copy-pastes each note from the *m-voice*, then alters the pitch, following a systematic rule used through a musical piece. The tintinnabuli consists in providing a *t-chord*, and for each note of the *m-voice*, get the pitch in the *t-chord* that is the closest to the pitch of the *m-voice* through a given direction: up, down, any or alternate. The *t-chord* can be anything, but it typically is a major or a minor triad. When you generate your `jm.generative.minimalism.Tintinnabuli` object, for each note in the *m-voice* track, the *t-voice* track will rank the next (higher pitch) or previous (lower pitch) notes in the *t-chord* depending on the direction you selected, then will select the rank from the position you specified. Each note in the *m-voice* will have its corresponding note in the *t-voice*, with the same duration.

### Showcase

For instance, I define the t-chord of my t-voice as a C major triad C, E G, I set direction to "up" and the rank to 1. The first note of my melody (m-voice) is a C4. Can you guess the t-voice? You go up from the C4, the next in your chord is E. But you chose `rank: 2`, so you look for the next, G. And it will be a G4 since you went up from the C4. The `extendOctaves` switch allows to expand the tChord across octaves when needed. Let's try the same t-voice properties on a simple monotonic C scale as the m-voice.
  </script>

  <script type="module" pinned>
const mVoice = solfege_track;
const tVoice = new jm.generative.minimalism.Tintinnabuli(
  { tChord: [60, 64, 67], direction: "down", rank: 0, extendOctaves: false }
).generate(mVoice);
const solfege_tintinabuli = {
  title: "Tintinabuli",
  tempo: 120,
  keySignature: "C-major",
  tracks: [
    {notes: mVoice, clef: "trebble"},
    {notes: tVoice, clef: "trebble"}
  ]
}
display({ mVoice, tVoice });
display(jm.score(solfege_tintinabuli, {ABCJS}));
display(await jm.play(solfege_tintinabuli, { Tone }));
  </script>

  <script type="text/markdown">
While the *m-voice* grows continuously, the t-voice grows more stepwise. See how the t-voice is restricted to the notes we set in `tChord = [60, 64, 67]`. You can choose any chord and position and going up with `direction = "up"` or down with `direction = "down"`. The library even allows alternating between up and down with `"alternate"` or to the nearest on `"any"` direction.

### Composition

I will add a t-voice in E major to track 1 as the m-voice, then go down an octave. Also, let's be a bit innovative here and offset the t-voice by a quarter length, on part *b* only.
  </script>

  <script type="module" pinned>
// mount track1 by chaining the tracks (adjusts timing so they play sequentially)
const track1 = jm.utils.chain(track1a, track1b, track1c);
const track2_tintinabuli = new jm.generative.minimalism.Tintinnabuli(
  { 
    tChord: [64, 68, 71, 74], // E major 7th
    direction: "up",
    rank: 0,
    extendOctaves: true
  }
).generate(track1);

// Offset the t-voice by a quarter note, but only for the "b" section
const track1a_end = track1a.length;
const track1b_end = track1a.length + track1b.length;
const track2_tintinabuli_bass = track2_tintinabuli.map((d, i) => ({
  pitch: d.pitch - 12,
  duration: d.duration,
  time: (i >= track1a_end && i < track1b_end) ? d.time + 0.25 : d.time,
  velocity: 0.6
}));

const piece_tintinabuli = {
  title: "Tintinabuli",
  tempo: 120,
  keySignature: "E-major",
  tracks: [
    {title: "track 1", notes: track1},
    {title: "track 2 (tintinabuli)", notes: track2_tintinabuli_bass}
  ]
}

display(await jm.play(piece_tintinabuli, { Tone }));
  </script>

  <script type="text/markdown">
I like it.. kind of. It certainly lacks rhythm.

## Voicing

Chords can be used to add a rhythmic structure, a feel of predictability to make my piece sounds less experimental and more enjoyable. The `Voice` class procedurally extracts root pitches at measure boundaries and generates chords from them. It wraps utilities like `chordify` and `findClosestPitchAtMeasureStart` with a clean `.generate()` API.

### Example

For the example, I will alter the durations of the solfège. The `Voice` class extracts the pitch closest to each measure start and builds chords from it. By default, it returns chord arrays, but you can set `output: 'track'` to get a JMON track.
  </script>

  <script type="module" pinned>
const solfegeAlterdur = jm.theory.rhythm.isorhythm(
  solfege_track.map(note => note.pitch),
  [1, 1.5, 1, 1.5, 1, 1, 0.5, 0.5]
);

// Create a voice generator that extracts roots at each 4-beat measure
const voiceC = new jm.theory.harmony.Voice({ 
  tonic: "C", 
  mode: "major", 
  measureLength: 4,
  output: 'track'
});

// Generate chords from the track
const solfegeChordsTrack = voiceC.generate(solfegeAlterdur);

const solfegeChordsPiece = {
  title: "Voicing",
  tempo: 120,
  keySignature: "C-major",
  tracks: [
    {notes: solfegeAlterdur, clef: "trebble"},
    {notes: solfegeChordsTrack, clef: "trebble"}
  ]
}

display(jm.score(solfegeChordsPiece, {ABCJS}));
  </script>

  <script type="text/markdown">
### Composition

I want to add a deep voicing track to the composition. The `Voice` class with `output: 'track'` extracts root notes and adds chords at measure boundaries. Combined with the `transpose` option, I can easily create a bass chord line two octaves below.
  </script>

  <script type="module" pinned>
// Create a bass voice: extracts roots at each measure, outputs as bass track, transposed down an octave
const bassVoice = new jm.theory.harmony.Voice({ 
  tonic: "E", 
  mode: "major",
  measureLength: 4,
  output: 'track',
  transpose: -12
});

const track3 = bassVoice.generate(track1).map(note => ({
  ...note,
  velocity: 0.5
}));
display(track3);
  </script>

  <script type="text/markdown">
Putting the three tracks together...
  </script>

  <script type="module" pinned>
// Create a JMON composition with GM instruments
const composition = {
  meta: {
    title: "Minimalist Composition",
    tempo: 120
  },
  tracks: [
    { name: "M-Voice", notes: track1, synth: 0 },
    { name: "T-Voice", notes: track2_tintinabuli_bass, synth: 19 },
    { name: "Chords", notes: track3, synth: 48 }
  ]
};

display(await jm.play(composition, { Tone }));
  </script>

  <script type="text/markdown">
It's kind of messy, but sounds like a pretty good experimentation to me!
  </script>

</notebook>
