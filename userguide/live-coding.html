<!doctype html>
<notebook>
  <title>Live Coding with jmon/live and jmon/algo</title>

  <script type="text/markdown">
# Live Coding with jmon/live and jmon/algo

This guide demonstrates how to use `jmon/live` together with `jmon/algo` for interactive, real-time music composition. The `jmon/live` player enables seamless pattern updates without interrupting playback, making it perfect for live coding performances and interactive musical exploration.

## What is jmon/live?

`jmon/live` is a web-based audio player that runs in an iframe and receives live updates via `postMessage`. It maintains a persistent Tone.js audio context that continues running while you send new musical patterns, creating a seamless live coding experience.

### Key Features

- **Persistent playback**: Audio continues uninterrupted when patterns update
- **Live pattern updates**: Uses `postMessage` for cross-iframe communication
- **Tone.js integration**: Precise audio scheduling and synthesis
- **No build required**: Standalone HTML/JavaScript files
- **Notebook ready**: Designed for Observable and Jupyter integration

## Setting Up the Live Player

To use the live player, you'll embed it in an iframe and communicate with it using `postMessage`.
  </script>

  <script type="module" pinned>
import jm from "../src/index.js";
import * as Tone from "npm:tone";
import * as ABCJS from "npm:abcjs";

// Create the live player iframe
const livePlayerUrl = "https://jmonlabs.github.io/live/";
const iframe = html`<iframe src="${livePlayerUrl}" style="width: 100%; height: 200px; border: 1px solid #ccc;"></iframe>`;

// Helper function to send patterns to the live player
const sendToLive = (pattern) => {
  iframe.contentWindow.postMessage(pattern, "*");
  return pattern;
};

// Display the player
display(iframe);
  </script>

  <script type="text/markdown">
## Your First Live Pattern

Let's start with a simple pattern. Create a basic scale and send it to the live player.
  </script>

  <script type="module" pinned>
// Create a simple C major scale
const scale = new jm.theory.harmony.Scale({tonic: "C", mode: "major"});
const pitches = scale.generate({ start: 60, length: 8 });
const durations = [1, 1, 1, 1, 1, 1, 1, 1];

// Create a track using isorhythm
const simpleTrack = jm.theory.rhythm.isorhythm(pitches, durations);

// Create the pattern
const pattern1 = {
  title: "Simple Scale",
  tempo: 120,
  tracks: [{ notes: simpleTrack }]
};

// Send to live player
sendToLive(pattern1);

// Also display the score
display(jm.score(pattern1, { ABCJS }));
  </script>

  <script type="text/markdown">
The pattern is now playing in the live player above! Try modifying the code and re-running the cell to hear the changes instantly.

## Live Coding with Isorhythms

One of the powerful features of live coding is the ability to experiment with different rhythmic patterns in real-time. Let's try creating more complex isorhythms.
  </script>

  <script type="module" pinned>
// Create interesting rhythmic patterns
const pitchPattern = new jm.theory.harmony.Scale({tonic: "E", mode: "minor"})
  .generate({ start: 64, length: 7 });

const rhythmPattern = [2, 1, 1, 0.5, 0.5, 1, 2, 0.5, 0.5, 1];

// The different lengths create evolving patterns
const isoTrack = jm.theory.rhythm.isorhythm(pitchPattern, rhythmPattern);

const pattern2 = {
  title: "Isorhythm Experiment",
  tempo: 140,
  tracks: [{ notes: isoTrack }]
};

sendToLive(pattern2);
display(jm.score(pattern2, { ABCJS }));
  </script>

  <script type="text/markdown">
Try changing the `rhythmPattern` array or the scale mode and re-run the cell to hear different variations!

## Live Minimalism: Additive Processes

Let's explore minimalistic composition techniques in real-time. Additive processes are perfect for live coding because they create gradually evolving patterns.
  </script>

  <script type="module" pinned>
// Create a base melody
const baseMelody = jm.theory.rhythm.isorhythm(
  [69, 64, 71, 67, 74, 66], // F# minor pitches
  [1, 0.5, 0.5, 1, 0.5, 0.5]
);

// Apply an additive forward process
const additive = new jm.generative.minimalism.Process({
  operation: "additive",
  direction: "forward",
  repetition: 0
}).generate(baseMelody);

const pattern3 = {
  title: "Additive Process",
  tempo: 100,
  tracks: [{ notes: additive }]
};

sendToLive(pattern3);
display(jm.score(pattern3, { ABCJS }));
  </script>

  <script type="text/markdown">
Try changing the `direction` to "backward" or the `operation` to "subtractive" to hear different effects!

## Live Tintinnabuli

The tintinnabuli technique creates beautiful harmonies by pairing a melody (m-voice) with a companion voice (t-voice) derived from a chord.
  </script>

  <script type="module" pinned>
// Create the m-voice (melody)
const mVoice = jm.theory.rhythm.isorhythm(
  new jm.theory.harmony.Scale({tonic: "D", mode: "dorian"}).generate({ start: 62, length: 8 }),
  [1.5, 0.5, 1, 1, 0.5, 0.5, 1, 1]
);

// Generate the t-voice from a D minor chord
const tVoice = new jm.generative.minimalism.Tintinnabuli({
  tChord: [62, 65, 69], // D minor triad
  direction: "down",
  rank: 0,
  extendOctaves: true
}).generate(mVoice);

// Transpose t-voice down an octave
const tVoiceBass = tVoice.map(note => ({
  ...note,
  pitch: note.pitch - 12,
  velocity: 0.6
}));

const pattern4 = {
  title: "Tintinnabuli",
  tempo: 90,
  keySignature: "D-minor",
  tracks: [
    { notes: mVoice },
    { notes: tVoiceBass }
  ]
};

sendToLive(pattern4);
display(jm.score(pattern4, { ABCJS }));
  </script>

  <script type="text/markdown">
Try changing the `direction` to "up" or "alternate", or modify the `tChord` to create different harmonic textures!

## Live Chord Progressions

You can also generate chord progressions and send them to the live player.
  </script>

  <script type="module" pinned>
// Create a melody with varied rhythms
const melody = jm.theory.rhythm.isorhythm(
  new jm.theory.harmony.Scale({tonic: "G", mode: "major"}).generate({ start: 67, length: 8 }),
  [1.5, 0.5, 1, 1, 0.5, 0.5, 1.5, 0.5]
);

// Generate chords from the melody
const voice = new jm.theory.harmony.Voice({
  tonic: "G",
  mode: "major",
  measureLength: 4,
  output: 'track',
  transpose: -12
});

const chords = voice.generate(melody).map(note => ({
  ...note,
  velocity: 0.5
}));

const pattern5 = {
  title: "Melody with Chords",
  tempo: 120,
  keySignature: "G-major",
  tracks: [
    { name: "Melody", notes: melody },
    { name: "Chords", notes: chords }
  ]
};

sendToLive(pattern5);
display(jm.score(pattern5, { ABCJS }));
  </script>

  <script type="text/markdown">
## Multi-Track Live Composition

Let's combine multiple techniques to create a richer composition that updates in real-time.
  </script>

  <script type="module" pinned>
// Track 1: Main melody with isorhythm
const track1Pitches = new jm.theory.harmony.Scale({tonic: "A", mode: "minor"})
  .generate({ start: 69, length: 6 });
const track1 = jm.theory.rhythm.isorhythm(track1Pitches, [1, 0.5, 0.5, 1, 0.5, 1.5]);

// Track 2: Tintinnabuli bass line
const track2 = new jm.generative.minimalism.Tintinnabuli({
  tChord: [69, 72, 76], // A minor triad
  direction: "up",
  rank: 1,
  extendOctaves: true
}).generate(track1).map(note => ({
  ...note,
  pitch: note.pitch - 12,
  velocity: 0.6
}));

// Track 3: Harmonic foundation
const track3 = new jm.theory.harmony.Voice({
  tonic: "A",
  mode: "minor",
  measureLength: 4,
  output: 'track',
  transpose: -24
}).generate(track1).map(note => ({
  ...note,
  velocity: 0.4
}));

const composition = {
  title: "Live Multi-Track Composition",
  tempo: 110,
  keySignature: "A-minor",
  tracks: [
    { name: "Melody", notes: track1, synth: 0 },
    { name: "Bass", notes: track2, synth: 32 },
    { name: "Foundation", notes: track3, synth: 48 }
  ]
};

sendToLive(composition);
display(jm.score(composition, { ABCJS }));
  </script>

  <script type="text/markdown">
## Random Walks for Live Exploration

Random walks can create unpredictable but musically coherent patterns. Let's use seeded randomness for reproducible experimentation.
  </script>

  <script type="module" pinned>
// Seeded random generator for reproducibility
const seededRandom = (seed) => () => (seed = (seed * 9301 + 49297) % 233280) / 233280;

// Fisher-Yates shuffle with seed
const shuffleWithSeed = (arr, seed) => {
  const rng = seededRandom(seed);
  const s = [...arr];
  for (let i = s.length - 1; i > 0; i--) {
    const j = Math.floor(rng() * (i + 1));
    [s[i], s[j]] = [s[j], s[i]];
  }
  return s;
};

// Create a base pattern and shuffle it
const basePattern = jm.theory.rhythm.isorhythm(
  new jm.theory.harmony.Scale({tonic: "Bb", mode: "major"}).generate({ start: 70, length: 8 }),
  [1, 1, 0.5, 0.5, 1, 1, 0.5, 1.5]
);

// Try different seeds to explore variations (change 42 to any number!)
const shuffled = jm.utils.recalculateTiming(
  shuffleWithSeed(basePattern, 42)
);

const pattern6 = {
  title: "Random Walk",
  tempo: 130,
  tracks: [{ notes: shuffled }]
};

sendToLive(pattern6);
display(jm.score(pattern6, { ABCJS }));
  </script>

  <script type="text/markdown">
Try changing the seed value (42) to different numbers and re-run the cell to explore different variations!

## Combining Processes

The real power of live coding comes from combining multiple generative techniques. Let's create a complex piece that uses additive processes, tintinnabuli, and voicing together.
  </script>

  <script type="module" pinned>
// Create a base motif
const motif = jm.theory.rhythm.isorhythm(
  [71, 68, 75, 73, 68, 66],
  [1, 0.5, 0.5, 1, 0.5, 0.5]
);

// Apply subtractive backward process
const processed = new jm.generative.minimalism.Process({
  operation: "subtractive",
  direction: "backward",
  repetition: 0
}).generate(motif);

// Add tintinnabuli
const tinti = new jm.generative.minimalism.Tintinnabuli({
  tChord: [68, 71, 75, 78], // Ab major 7th
  direction: "up",
  rank: 0,
  extendOctaves: true
}).generate(processed).map(note => ({
  ...note,
  pitch: note.pitch - 12,
  velocity: 0.55
}));

// Add voicing
const voicing = new jm.theory.harmony.Voice({
  tonic: "Ab",
  mode: "major",
  measureLength: 4,
  output: 'track',
  transpose: -24
}).generate(processed).map(note => ({
  ...note,
  velocity: 0.35
}));

const complexComposition = {
  title: "Complex Live Composition",
  tempo: 95,
  keySignature: "Ab-major",
  tracks: [
    { name: "Processed Melody", notes: processed, synth: 11 },
    { name: "Tintinnabuli", notes: tinti, synth: 4 },
    { name: "Harmonic Base", notes: voicing, synth: 48 }
  ]
};

sendToLive(complexComposition);
display(jm.score(complexComposition, { ABCJS }));
  </script>

  <script type="text/markdown">
## Tips for Live Coding

1. **Start Simple**: Begin with simple patterns and gradually add complexity
2. **Use Seeds**: Seeded random functions let you reproduce "happy accidents"
3. **Layer Gradually**: Add tracks one at a time to build up your composition
4. **Experiment with Tempo**: Different tempos can dramatically change the feel
5. **Combine Techniques**: Mix deterministic and stochastic processes
6. **Trust Your Ears**: If it sounds good, it is good!

## What's Next?

Now that you understand how to use `jmon/live` for real-time music composition, try:

- Creating your own generative algorithms
- Exploring different scale modes and tonalities
- Building performance pieces that evolve over time
- Combining with other data sources for data sonification
- Creating educational demonstrations of music theory concepts

## Additional Resources

- [jmon/algo User Guide](index.html) - Complete guide to the jmon/algo library
- [Minimalism](05-minimalism.html) - Deep dive into minimalistic composition
- [Harmonies](02-harmonies.html) - Understanding scales and chords
- [Fractals](07-fractals.html) - Fractal-based composition techniques

Happy live coding! ðŸŽµ
  </script>

</notebook>
