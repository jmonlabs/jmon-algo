<!doctype html>
<notebook>
  <title>6. Walks</title>
  
  <script type="text/markdown">
# 6. Walks

Random and kernel walks represent fascinating techniques that have found applications in various fields. Each step of a walk is a consequence of the previous state, creating coherent yet unpredictable progressions. Walks have been embraced by composers and sound artists to wander through new territories of algorithmic music. Iannis Xenakis, a composer and architect, is perhaps one of the most renowned composers to integrate random processes, including random walks, into his compositions. Works like [Mikka](https://www.youtube.com/watch?v=Ifxs3TBSSAs) and [Epeï](https://www.youtube.com/watch?v=8ZP3TbLtfq4) are seminal examples where randomized methods contribute to the structural foundation of the music. Karlheinz Stockhausen and his work with controlled randomness and serial techniques also touch upon concepts akin to random walks. His compositions, such as [Klavierstück XI](https://www.youtube.com/watch?v=mMDdihXI98A), employ a form of controlled chance that dictates the sequence of musical events, offering a multitude of possible paths through the piece.

The application of random walks in music composition involves generating sequences of musical elements, usually pitches and sequences, where each element is selected based on a combination of random choice and a set of rules or conditions influenced by previous elements. This approach allows composers to explore new forms of musical structure and texture, creating pieces that can vary greatly with each performance or realization while maintaining an underlying coherence.
  </script>

  <script type="module" pinned>
import jm from "../src/index.js";
import * as Tone from "npm:tone";
import verovio from "npm:verovio@4.3.1/wasm";
import * as Plot from "npm:@observablehq/plot";
import ds from "@tangent.to/ds"; // for Gaussian processes
  </script>

  <script type="text/markdown">
In this section, we will also cover *kernel walks*, an innovative technique akin to random walks. This approach digs into well-known statistical objects named Gaussian processes to generate randomly oscillating paths. Most interestingly, kernel walks can be forced to pass through predefined points, and create melodies wandering around predefined progressions.

Some walks can offer perfectly predictable, although intricate patterns. An example is the movements of planets in solar systems. Imagine a planet orbiting the sun with a circular orbit. The distance from the sun is steady, and the angle grows linearly from 0 to 360, then goes back to zero to create a saw wave. Then a moon orbits the planet, then a moon orbits the moon, and so on. The movements are predictable, but the periodic shape can create interesting patterns. *Celestial walks* are also part of jmon/algo.

Finally, walks are additive and multiplicative. You can, at will, add up a random walk to a celestial walk.

## Random walks

A random walk is a mathematical process where each step is a random choice relative to the one preceding it. Mathematicians call them Markov chains, named after mathematician Andrey Markov. The random choice can be as simple as a coin flip: if it goes tail, you take a diagonal step left. Heads, a diagonal step on right. Repeat the process over and over and you obtain a random walk. On average, you should walk ahead, but in fact, you'll probably derive from a straight path.

### Understanding randomness

A mathematical function using a probability distribution is named a *stochastic* function. The concept of randomness is often misunderstood. It's not about everything being possible without constraints. When we talk about selecting a random number, the process is not as open-ended as it might seem. When you flip a coin, it's either heads or tails (or, rarely, the edge...).

Randomness is structured by probability distributions, a collection of mathematical functions structuring randomness and approximate processes underlying a reality too complex to be perfectly predictable. The coin toss is a binomial distribution: it's either true or false. Another familiar example is the Normal distribution, known for its bell-shaped curve. When we sample from this distribution, values near the mean (centre of the curve) are more likely to occur than those far from it, say, more than 4 units away or less than -4 units from the mean. The Normal distribution is characterized by two parameters: the mean, which locates the centre of the curve, and the standard deviation, which determines the width of the curve.

There are numerous probability distributions, catering to different types of data:
- **Continuous values**: Normal distribution or uniform distribution (flat probability across a range)
- **Discrete/categorical data**: Multinomial distribution (set of probabilities summing to 1)
- **Counting occurrences**: Poisson distribution (produces integers)

Understanding these distributions helps in contextualizing randomness, especially in creative domains like music, where generating random rhythms involves selecting from a defined range of possibilities according to a specific probability distribution.
  </script>

  <script type="module">
// Visualize common probability distributions
// Normal distribution (bell curve)
const normalData = Array.from({ length: 100 }, (_, i) => {
  const x = -4 + (i / 99) * 8;
  const y = Math.exp(-0.5 * x * x) / Math.sqrt(2 * Math.PI);
  return { x, y, dist: "Normal" };
});

// Uniform distribution (flat)
const uniformData = Array.from({ length: 100 }, (_, i) => {
  const x = -4 + (i / 99) * 8;
  const y = (x >= -1 && x <= 1) ? 0.5 : 0;
  return { x, y, dist: "Uniform" };
});

// Multinomial (categorical)
const categories = ["Folk", "Classic", "Punk", "Jazz"];
const probs = [0.15, 0.30, 0.10, 0.45];
const multinomialData = categories.map((cat, i) => ({ category: cat, probability: probs[i] }));

// Poisson distribution (discrete counts)
const poissonData = Array.from({ length: 10 }, (_, k) => {
  const mu = 3;
  const prob = Math.exp(-mu) * Math.pow(mu, k) / Array.from({ length: k + 1 }, (_, i) => i || 1).reduce((a, b) => a * b);
  return { k, probability: prob };
});

display(html`<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
  <div>
    ${Plot.plot({
      title: "Normal Distribution",
      height: 200,
      marks: [Plot.line(normalData, { x: "x", y: "y", stroke: "#1f77b4" })]
    })}
  </div>
  <div>
    ${Plot.plot({
      title: "Uniform Distribution",
      height: 200,
      marks: [Plot.line(uniformData, { x: "x", y: "y", stroke: "#ff7f0e" })]
    })}
  </div>
  <div>
    ${Plot.plot({
      title: "Multinomial Distribution",
      height: 200,
      marks: [Plot.barY(multinomialData, { x: "category", y: "probability", fill: "#2ca02c" })]
    })}
  </div>
  <div>
    ${Plot.plot({
      title: "Poisson Distribution (μ=3)",
      height: 200,
      marks: [Plot.barY(poissonData, { x: "k", y: "probability", fill: "#d62728" })]
    })}
  </div>
</div>`);
  </script>

  <script type="text/markdown">
### Logic of the random walk

Random walks in jmon/algo are generated through the `Chain` class. The random walk generator takes several arguments:

- `walkRange`: A list of minimum and maximum numbers to confine the walk (to create a *bounded* random walk). For instance, `walkRange: [-10, 10]` restrains the walk between -10 and 10.
- `walkProbability`: Can take a list of numbers like `[-1, 0, 1]` for steps of -1, 0, and 1. It can also take a distribution function.
- `walkStart`: The starting point of the walk.
- `length`: The number of steps.
- `roundTo`: Rounds stepping to a given decimal (default: null).
- `branchingProbability`: Probability (0 to 1) to create a new branch.
- `mergingProbability`: Probability to merge random walks when they collide.

### Example

Let's generate a random walk through pitches from C2 to C8, starting at C4. MIDI pitch numbers: C2 = 36, C4 = 60, C8 = 108.
  </script>

  <script type="module" pinned>
// The random walk will be conducted between numbers 36 to 108, starting at 60
const rw = new jm.generative.walks.Chain({
  walkRange: [36, 108],
  walkStart: 60,
  walkProbability: [-2, -1, 0, 1, 2],
  roundTo: 0,
  branchingProbability: 0.1,
  mergingProbability: 0.9
});

const rwSequences = rw.generate(20, 6);  // length, seed
display("Number of branches: " + rwSequences.length);
  </script>

  <script type="text/markdown">
The `rwSequences` object contains the generated random walk branches. Each branch is a list of pitch values representing the random walk through the specified range. The branching and merging probabilities influence how many branches are created and how they interact with each other.
  </script>

  <script type="module">
// Plot the random walk branches
const rwPlotData = [];
for (let i = 0; i < rwSequences.length; i++) {
  for (let step = 0; step < rwSequences[i].length; step++) {
    const val = rwSequences[i][step];
    if (val !== null) {
      rwPlotData.push({ 
        step: step, 
        pitch: val, 
        branch: "Branch " + (i + 1) 
      });
    }
  }
}

display(Plot.plot({
  title: "Random walk branches",
  height: 300,
  color: { legend: true },
  marks: [
    Plot.line(rwPlotData, { x: "step", y: "pitch", stroke: "branch", strokeWidth: 2 }),
    Plot.dot(rwPlotData, { x: "step", y: "pitch", fill: "branch" })
  ]
}));
  </script>



  <script type="text/markdown">
The `rwSequences` contains multiple branches. If you examine the object, you will see lists beginning with `null` values, which are generated when a new branch is created to make sure all branches are generated with the same length. Each branch then has its own random walk, and can branch out. If two or more branches collide to the same values, and if merging is true according to `mergingProbability`, lists are closed with `null` values to the following notes.

We can map pitches to durations by creating a rhythm for each track.
  </script>

  <script type="module" pinned>
const measureLength = 4;
const rwNotes = [];
const rhythmDurations = [ // different rhythm choices
  [0.125, 0.25, 0.5, 1, 2],
  [1, 2],
  [1, 2],
  [1, 1, 2],
  [0.5, 1, 2]
];
const nTracks = Math.min(rwSequences.length, rhythmDurations.length);

for (let i = 0; i < nTracks; i++) {
  const seq = rwSequences[i].filter(v => v !== null); // Remove nulls for rhythm mapping
  const rhythmPattern = new jm.theory.rhythm.Rhythm(measureLength, rhythmDurations[i]).random(6 + i); // Build random rhythms from choices in rhythmDurations[i]
  const dur = rhythmPattern.map(r => r.duration); // Extract durations from rhythm
  const iso = jm.theory.rhythm.isorhythm(seq, dur); // Apply isorhythm
  rwNotes.push(iso); // Store the notes for the track
}

const rwPiece = {
  title: "Random Walk",
  tempo: 120,
  tracks: rwNotes.map((notes, i) => ({ name: `Branch ${i+1}`, notes: notes, synth: 0 }))
};
display(await jm.play(rwPiece, { Tone }));
  </script>

  <script type="text/markdown">
The notes wander on the chromatic scale. To provide a little structure to a walk, we can wander through indices of a scale list rather than on notes.
  </script>

  <script type="module" pinned>
const gMajor = new jm.theory.harmony.Scale({ tonic: "G", mode: "major" }).generate({ start: 39, length: 14 });

const rwIndex = new jm.generative.walks.Chain({
  walkRange: [0, gMajor.length - 1],
  walkStart: 7,
  walkProbability: [-2, -1, 0, 1, 2],
  roundTo: 0,
  branchingProbability: 0.15,
  mergingProbability: 0.9
}).generate(30, 1);  // length, seed

display("Number of tracks: " + rwIndex.length);
  </script>

  <script type="text/markdown">
I can generate different rhythms from draws from a single list. Setting seed at the beginning assures that random processes provide the same results, avoiding losing an interesting pattern because it was random and can't be recovered.
  </script>

  <script type="module" pinned>
const measureLengthTuned = 3;
const rwNotesTuned = [];
const nTracksTuned = Math.min(rwIndex.length, rhythmDurations.length);

for (let i = 0; i < nTracksTuned; i++) {
  const seq = rwIndex[i].filter(v => v !== null);
  const rhythmPattern = new jm.theory.rhythm.Rhythm(measureLengthTuned, rhythmDurations[i]).random();
  const dur = rhythmPattern.map(r => r.duration);
  const pitches = seq.map(idx => gMajor[Math.round(idx)]);
  const iso = jm.theory.rhythm.isorhythm(pitches, dur);
  rwNotesTuned.push(iso);
}

const rwTunedPiece = {
  title: "Random walk in G major",
  tempo: 120,
  tracks: rwNotesTuned.map((notes, i) => ({ name: `Track ${i+1}`, notes: notes, synth: 0 }))
};
display(await jm.play(rwTunedPiece, { Tone }));
  </script>

  <script type="text/markdown">
## Gaussian processes

A normal distribution is a mathematically elegant way of describing the average and variance among a population. We can stack as many normal distributions as the amount of variables describing a population. When we think that our variables are linked to one another, we can merge normal distributions together in a single multivariate normal distribution.

To go even further, since time is continuous, our multivariate normal can contain an infinity of dimensions. A multivariate normal distribution with infinite number of dimensions is called a **Gaussian process**.

### Why use Gaussian processes?

These functions can be used just as we used random walks. So why bother with abstract mathematical concepts if you could just use a random walk function? Because Gaussian processes carry very interesting properties. Most importantly, they can be *fitted* to data, allowing melodies to pass through predefined points.

### Unfitted Gaussian processes

Unfitted Gaussian processes are only described by their kernel. Random samples from a kernel will create a pattern for music to follow. The kernel has two key properties:

- `lengthScale`: Describes the inertia of the covariance. Larger lengths create longer waves.
- `amplitude`: Describes the amplitude of the wave.

The following plot shows how different `lengthScale` and `amplitude` parameters affect the generated patterns:
  </script>

  <script type="module">
// Generate kernel walks with different parameters using ds GaussianProcessRegressor
const kernelParams = [
  { ls: 0.5, amp: 1.0 },
  { ls: 2.0, amp: 1.0 },
  { ls: 5.0, amp: 1.0 },
  { ls: 2.0, amp: 0.5 },
  { ls: 2.0, amp: 2.0 },
  { ls: 2.0, amp: 5.0 }
];

// Create x values: [[0], [1], [2], ..., [49]]
const xTest = Array.from({ length: 50 }, (_, i) => [i]);

// Generate samples for each parameter set
const kernelPlotData = kernelParams.flatMap(({ ls, amp }) => {
  const kernel = new ds.ml.RBF({ lengthScale: ls, amplitude: amp });
  const gp = new ds.ml.GaussianProcessRegressor({ kernel, noiseLevel: 0.1 });
  const samples = gp.samplePrior(xTest, 1, ls * 1000)[0];

  // Map each sample to a plot point
  const points = samples.map((y, x) => ({
    x,
    y,
    params: `ls=${ls}, amp=${amp}`
  }));

  return points;
});

display(Plot.plot({
  title: "Kernel walks: effect of `lengthScale` and `amplitude`",
  height: 600,
  color: { legend: true },
  facet: { data: kernelPlotData, y: "params" },
  marks: [
    Plot.line(kernelPlotData, { x: "x", y: "y", stroke: "params" }),
    Plot.frame()
  ]
}));
  </script>

  <script type="text/markdown">
Just like random walks, the signal of a Gaussian process can be transformed to really anything: pitches, scale indices, durations, MIDI channel, etc. Let's use it here to generate scale indices from a B blues scale.
  </script>

  <script type="module" pinned>
// B minor pentatonic (closest available scale to blues)
const bBluesScale = new jm.theory.harmony.Scale({ 
  tonic: "B", 
  mode: "minor pentatonic" 
}).generate({ start: 53, length: 13 });

const bluesScaleLength = bBluesScale.length;
display("Blues scale: " + bBluesScale.join(", "));
  </script>

  <script type="text/markdown">
The next block generates samples from a Gaussian process, converts indices to pitches, then creates chords with a random rhythm.
  </script>

  <script type="module" pinned>
// Step 1: Set up the Gaussian process
const bluesSeed = 42;
const bluesLength = 16;
const bluesNtracks = 3;

const bluesKernel = new ds.ml.RBF({ lengthScale: 2.0, amplitude: 5.0 });
const bluesGP = new ds.ml.GaussianProcessRegressor({
  kernel: bluesKernel,
  noiseLevel: 0.1
});

const xBlues = Array.from({ length: bluesLength }, (_, i) => [i]);
const rawTracks = bluesGP.samplePrior(xBlues, bluesNtracks, bluesSeed);

display(rawTracks);
  </script>

  <script type="text/markdown">
Now let's transform those raw GP values into valid scale indices:
  </script>

  <script type="module" pinned>
// Step 2: Transform to scale indices
const bluesTracksData = rawTracks.map(track => {
  return track.map(value => {
    const index = Math.round(value + 4);
    return Math.max(0, Math.min(bluesScaleLength - 1, index));
  });
});

display(bluesTracksData);
  </script>

  <script type="text/markdown">
Let's visualize these scale indices over time:
  </script>

  <script type="module" pinned>
// Step 3: Plot the scale indices
const bluesPlotData = bluesTracksData
  .map((track, trackIndex) => {
    const signalLabel = `Signal ${trackIndex + 1}`;
    return track.map((y, x) => ({ x, y, signal: signalLabel }));
  })
  .flat();

display(Plot.plot({
  title: "GP samples as scale indices",
  height: 250,
  x: { label: "Time (quarter notes)" },
  y: { label: "Scale index" },
  color: { legend: true },
  marks: [
    Plot.line(bluesPlotData, { x: "x", y: "y", stroke: "signal", strokeWidth: 2 }),
    Plot.dot(bluesPlotData, { x: "x", y: "y", fill: "signal" })
  ]
}));
  </script>

  <script type="text/markdown">
Convert all three tracks' scale indices to pitches:
  </script>

  <script type="module" pinned>
// Step 4: Convert all three tracks to pitches
const bluesMelodies = bluesTracksData.map(track => {
  return track.map(scaleIndex => bBluesScale[scaleIndex]);
});

display("Three melodic lines:");
display(bluesMelodies);
  </script>

  <script type="text/markdown">
Add rhythm to all three tracks:
  </script>

  <script type="module" pinned>
// Step 5: Add rhythm to all tracks
const bluesRhythm = new jm.theory.rhythm.Rhythm(8, [0.5, 1, 2, 4]).random(bluesSeed);
const durations = bluesRhythm.map(r => r.duration);

const bluesTracks = bluesMelodies.map(melody => {
  return jm.theory.rhythm.isorhythm(melody, durations);
});

display("Track 1 with durations:");
display(bluesTracks[0].slice(0, 5));
  </script>

  <script type="text/markdown">
Use Voice to create bass chords from the third track:
  </script>

  <script type="module" pinned>
// Step 6: Create bass chords using Voice
const bluesVoice = new jm.theory.harmony.Voice({
  tonic: "B",
  mode: "minor pentatonic",
  measureLength: 2,
  output: 'track',
  transpose: -24
});

const bluesChords = bluesVoice.generate(bluesTracks[2]);

const strummedChords = jm.theory.harmony.strum(bluesChords, {
  direction: "random",
  speed: 0.05
}).map(note => ({
  ...note,
  duration: 0.5  // Raccourcir pour éviter les chevauchements dans la partition
}));

display(strummedChords.slice(0, 5));
  </script>

  <script type="text/markdown">
Play all three tracks together:
  </script>

  <script type="module" pinned>
// Step 7: Play first two tracks as melodies + third as chords
const bluesPiece = {
  title: "Gaussian blues",
  tempo: 140,
  tracks: [
    { label: "Guitar 1", notes: bluesTracks[0], clef: "trebble", synth: 27 },
    { label: "Guitar 2", notes: bluesTracks[1], clef: "trebble", synth: 28 },
    { label: "Bass", notes: strummedChords, clef: "bass", synth: 32 }
  ]
};

display(await jm.score(bluesPiece, { verovio }));
display(await jm.play(bluesPiece, { Tone }));
  </script>

  <script type="text/markdown">
### Fitted Gaussian processes

One very interesting aspect of Gaussian processes is that they can be conditioned on known data. When a Gaussian process is fitted on data, the fundamental question you ask is: what function might the data have followed? A fitted Gaussian process can generate variations that pass through those points.

An interesting question to ask: what variations can be extracted from Pachelbel's progression?
  </script>

  <script type="module" pinned>
const pachelbelTonic = "D";
const pachelbelMode = "major";
const largeScale = new jm.theory.harmony.Scale({ tonic: pachelbelTonic, mode: pachelbelMode })
  .generate({ start: 36, length: 36 });
const pachelbelOctave = 4;
const pachelbelTonicMidi = jm.utils.cdeToMidi(pachelbelTonic + pachelbelOctave);
const pachelbelProgressionPitchOffsets = [0, -5, -3, -8, -7, -12, -7, -5, 0]; // D, A, B, F#, G, D, G, A, D
const pachelbelProgressionMidi = pachelbelProgressionPitchOffsets.map(offset => pachelbelTonicMidi + offset);

// generate chords from midi pitches
const pachelbelProgressionChords = jm.theory.harmony.chordifyMany(
  pachelbelProgressionMidi,
  { tonic: pachelbelTonic, mode: pachelbelMode, degrees: [0, 2, 4] }
);

// Assemble to JMON format
const pachelbelDuration = 4;
const pachelbelProgressionTrack = pachelbelProgressionChords.map((chord, i) => ({
  pitch: chord,
  duration: pachelbelDuration,
  time: i * pachelbelDuration
}));

display(
  await jm.score(
  { 
    title: "Pachelbel Progression",
    tracks: [{ notes: pachelbelProgressionTrack , clef: "trebble"}] 
  },
  { verovio }
  )
);

  </script>

  <script type="text/markdown">
Modeling raw MIDI pitches would likely push the Gaussian process outside the D major scale. Instead, we convert every Pachelbel chord root to its **scale index** inside `largeScale`. The GP now learns how those indices evolve over time, ensuring that any sampled value still maps back to an in-scale pitch.
  </script>

  <script type="module" pinned>
const chordDuration = 4; // whole notes

// Helper to fall back to the closest scale tone if a pitch is missing (shouldn't happen here)
const nearestScaleIndex = pitch => {
  let bestIdx = 0;
  let bestDelta = Infinity;
  largeScale.forEach((scalePitch, idx) => {
    const delta = Math.abs(scalePitch - pitch);
    if (delta < bestDelta) {
      bestDelta = delta;
      bestIdx = idx;
    }
  });
  return bestIdx;
};

const pachelbelProgressionIndices = pachelbelProgressionMidi.map(pitch => {
  const idx = largeScale.indexOf(pitch);
  return idx !== -1 ? idx : nearestScaleIndex(pitch);
});

const data = pachelbelProgressionIndices.map((index, i) => ({
  time: i * pachelbelDuration,
  index
}));

display(data);
const maxTime = Math.max(...data.map(d => d.time));
const normalizeTime = time => time / Math.max(maxTime, 1);
  </script>

  <script type="text/markdown">
When data are provided, the `Kernel` class interpolates, fits the model, then exports results in time and model predictions.
  </script>

  <script type="module" pinned>
// Create the kernel - we use a generic RBF kernel plus a constant kernel to center the GP
const rbfKernel = new ds.ml.RBF({ lengthScale: 0.03, amplitude: 8.0 });
const constantKernel = new ds.ml.ConstantKernel({ value: 12 });
const pachelbelKernel = new ds.ml.SumKernel({ kernels: [constantKernel, rbfKernel] });

// Create the Gaussian Process Regressor
const fittedGP = new ds.ml.GaussianProcessRegressor({ kernel: pachelbelKernel, noiseLevel: 0.001 });
  </script>

  <script type="text/markdown">
When data are provided, the `Kernel` class interpolates, fits the model, then exports results in time and model predictions.
  </script>

  
  <script type="module" pinned>
// Fit the GP on the Pachelbel data
const xData = data.map(d => [normalizeTime(d.time)]);
const yData = data.map(d => d.index);
fittedGP.fit(xData, yData);

// Generate prediction points spanning the time range
const pachelbelLength = 100; // number of time points to smooth
const pachelbelTracksT = Array.from({ length: pachelbelLength }, (_, i) => i * (maxTime / (pachelbelLength - 1))); // time points for prediction (100 points, 0 to maxTime)
const xPred = pachelbelTracksT.map(t => [normalizeTime(t)]);

// Sample from the posterior (fitted GP)
const ntracks = 3; // number of kernel samples to generate
const pachelbelTracksP = fittedGP.sample(xPred, ntracks, ntracks);
const posterior = fittedGP.predict(xPred, { returnStd: true });

// Plot the fitted GP samples with the original data points
const gpPlotData = [];
for (let i = 0; i < ntracks; i++) {
  if (pachelbelTracksP[i]) { // if the track exists
    for (let j = 0; j < pachelbelTracksT.length; j++) { // for each time point
      gpPlotData.push({ // add a time value, a scale index and a signal name
        time: pachelbelTracksT[j],
        index: pachelbelTracksP[i][j],
        signal: `Signal ${i + 1}`
      });
    }
  }
}

// Add original data points
const dataPoints = data.map(d => ({ time: d.time, index: d.index, signal: "Data" }));
display(dataPoints)

display(Plot.plot({
  title: "Fitted Gaussian process - variations on Pachelbel's canon",
  height: 300,
  x: { label: "Time" },
  y: { label: "Scale index" },
  color: { legend: true },
  marks: [
    Plot.line(gpPlotData, { x: "time", y: "index", stroke: "signal", strokeWidth: 1.5 }),
    Plot.dot(dataPoints, { x: "time", y: "index", fill: "black", r: 6, symbol: "circle" })
  ]
}));
  </script>

  <script type="text/markdown">
For each track, let's create a random rhythm, interpolate those times against the GP indices, snap them back onto the scale, and assemble the notes.
  </script>

  <script type="module" pinned>
const pachelbelTracks = [];
for (let i = 0; i < ntracks; i++) { // for each track
  const rhythm = new jm.theory.rhythm.Rhythm(8, [0.5, 1, 2]).random(10 + i); // each track has its own rhythm
  const cloneWithOffset = offset => rhythm.map(event => ({
    duration: event.duration,
    time: event.time + offset
  }));
  const moreRhythm = [
    ...rhythm,
    ...cloneWithOffset(8),
    ...cloneWithOffset(16)
  ]; // extend the rhythm for a longer piece
  
  // Interpolate pitch indices at each rhythm point
  const notes = moreRhythm.map(r => {
    const t = r.time; // time when the beat is triggered on
    let idx = 0;
    for (let j = 0; j < pachelbelTracksT.length - 1; j++) { // all time indices on the prediction scale
      if (t >= pachelbelTracksT[j] && t <= pachelbelTracksT[j + 1]) { // if the time falls between two prediction times (rhythm could be off the prediction scale)
        const ratio = (t - pachelbelTracksT[j]) / (pachelbelTracksT[j + 1] - pachelbelTracksT[j]); // interpolation ratio
        idx = pachelbelTracksP[i][j] + ratio * (pachelbelTracksP[i][j + 1] - pachelbelTracksP[i][j]); // linear interpolation of the index
        break;
      }
    }
    idx = Math.round(idx);
    idx = Math.max(0, Math.min(idx, largeScale.length - 1));
    return { pitch: largeScale[idx], duration: r.duration, time: r.time };
  });
  pachelbelTracks.push(notes);
}
display(pachelbelTracks);
  </script>

  <script type="text/markdown">
We can offset the tracks to create a canon. The result is a reinterpretation of Pachelbel's Canon in D major (a Gauss canon!).
  </script>

  <script type="module" pinned>
// Offset tracks to create a canon effect
const offsetTracks = pachelbelTracks.map((track, i) => 
  track.map(note => ({ ...note, time: note.time + (i + 4) }))
);

// Add the original progression as bass
offsetTracks.push(pachelbelProgressionTrack);

const gaussCanon = {
  title: "Gauss Canon in D",
  tempo: 140,
  keySignature: "D-major",
  tracks: offsetTracks
    .map((notes, i) => ({ 
      notes,
      synth: 0
    }))
};
display(await jm.score(gaussCanon, { verovio }));
display(await jm.play(gaussCanon, { Tone }));
  </script>

  <script type="text/markdown">
## Phasor walks

`Phasor.Vector` and `Phasor.System` classes simulate objects rotating one around another, like celestial bodies in a star system, that can create complex periodic patterns. Each phasor has a distance (radius), frequency (orbital speed), and phase. Phasors can have sub-phasors (epicycles) to create spirographic patterns.
  </script>

  <script type="module" pinned>
// Create a phasor system with nested rotating vectors
// Inner phasor (astronaut around a moon)
const astronaut = new jm.generative.walks.Phasor.Vector(
  0.1, // distance (radius)
  0.2, // frequency (orbital speed) 
  Math.PI / 2 // phase offset
);

// Middle phasor (a moon) with the astronaut attached
const middlePhasor = new jm.generative.walks.Phasor.Vector(
  0.5, 3, Math.PI / 4,
  [astronaut]  // sub-phasors
);

// Outer phasor (a planet) with the middle phasor attached
const outerPhasor = new jm.generative.walks.Phasor.Vector(
  5.0, 4, Math.PI, [middlePhasor]
);

// Create the system and add the planet
const phasorSystem = new jm.generative.walks.Phasor.System();
phasorSystem.addPhasor(outerPhasor);
display(phasorSystem)
  </script>

  <script type="text/markdown">
We run the simulation to obtain positions and angles of the phasors.
  </script>

  <script type="module" pinned>
// Generate time array for simulation
const celestialSteps = 100;
const celestialDuration = 10;
const timeArray = jm.generative.walks.Phasor.System.generateTimeArray(0, celestialDuration, celestialSteps);

// Simulate the phasor system
const celestialResults = phasorSystem.simulate(timeArray);
display("Phasor simulation complete with " + celestialResults.length + " phasor groups");

// Plot distance and angle over time
const phasorPlotData = celestialResults[0].map(r => ({
  time: r.time,
  distance: r.distance,
  angle: r.angle
}));

display(Plot.plot({
  title: "Phasor distance from origin",
  height: 250,
  x: { label: "Time" },
  y: { label: "Distance" },
  marks: [Plot.line(phasorPlotData, { x: "time", y: "distance", stroke: "#1f77b4" })]
}));
  </script>

  <script type="module" pinned>
display(Plot.plot({
  title: "Phasor angle",
  height: 250,
  x: { label: "Time" },
  y: { label: "Angle (degrees)" },
  marks: [Plot.line(phasorPlotData, { x: "time", y: "angle", stroke: "#ff7f0e" })]
}));
  </script>

  <script type="text/markdown">
These attributes can be turned to music at will. For example, we could map the distance to pitch and angle to duration.
  </script>

  <script type="module" pinned>
// Extract distance and angle data from the simulation results
// celestialResults is an array of phasor result arrays
// Each result contains {time, position, distance, angle}
const phasorData = celestialResults[0]; // Get first phasor group

const distances = phasorData.map(r => r.distance);
const angles = phasorData.map(r => r.angle);

// Build a C major scale covering the pitch range, then map distances to scale indices
const cMajor = new jm.theory.harmony.Scale({ tonic: "E", mode: "minor" }).generate({
  start: 28, // MIDI pitch for E1 
  length: 24 // enough degrees to cover several octaves within the pitchRange
});

const maxDist = Math.max(...distances);
const minDist = Math.min(...distances);

const celestialPitches = distances.map(d => {
  const t = (d - minDist) / (maxDist - minDist); // normalized distances between 0 and 1
  const idx = Math.round(t * (cMajor.length - 1)); // normalize again to integers between 0 and scale length
  return cMajor[idx];
});

// Map angles to durations:
const normAngles = angles.map(a => 0.25 + 0.75 * a / 360); // durations between 0.25 and 1.0

// Build isorhythm from mapped pitches and durations
const celestialTrack = jm.theory.rhythm.isorhythm(celestialPitches, normAngles)
  .map((d) => ({ ...d, velocity: 0.6 })); // lower velocity
const voiceTrack = new jm.theory.harmony.Voice({
  tonic: "C",
  mode: "major",
  measureLength: 4,
  output: 'track',
  transpose: -12
})
  .generate(celestialTrack)
  .map((d) => ({ ...d, velocity: 0.25 })); // lower velocity

const celestialPiece = {
  title: "Phasor Walk",
  tempo: 140,
  tracks: [{ notes: celestialTrack, synth: 31 }, { notes: voiceTrack, synth: 19 }]
};
display(await jm.play(celestialPiece, { Tone }));

display(voiceTrack);

  </script>

  <script type="text/markdown">
## Fibonacci

The Fibonacci sequence creates interesting patterns when applied to music. In jmon/algo, `jm.utils.fibonacci()` is an iterator that returns the next number of the sequence each time it's called. Let's generate the first 30 Fibonacci numbers and apply modulo 7 to map them to scale degrees. The modulo operator takes the remainder of division, so `fibNumber % 7` will yield a number between 0 and 6.
  </script>

  <script type="module" pinned>
const fibDegrees = [];
const fib = jm.utils.fibonacci(); // iterator with internal state
for (let i = 0; i < 30; i++) {
  fibDegrees.push(fib.next().value % 7);
}

const fibPlotData = fibDegrees.map((deg, i) => ({ step: i, degree: deg }));
display(Plot.plot({
  title: "Fibonacci sequence with modulo of 7",
  height: 200,
  x: { label: "Step" },
  y: { label: "Degree", domain: [0, 6] },
  marks: [
    Plot.line(fibPlotData, { x: "step", y: "degree", stroke: "#2ca02c" }),
    Plot.dot(fibPlotData, { x: "step", y: "degree", fill: "#2ca02c" })
  ]
}));
  </script>

  <script type="text/markdown">
Mapping the degree to a pitch is easy.
  </script>

  <script type="module" pinned>
const cMajor = new jm.theory.harmony.Scale({ tonic: "C", mode: "major" }).generate({ start: 60, length: 8 });
const fibonacciPitches = fibDegrees.map(deg => cMajor[deg]);
display(fibonacciPitches);
  </script>

  <script type="text/markdown">
Let's map pitches to rhythms and hear what our Fibonacci sequence sounds like.
  </script>

  <script type="module" pinned>
const fibDurations = [1, 0.25, 0.25, 0.5, 2];
const fibonacciNotes = jm.theory.rhythm.beatcycle(fibonacciPitches, fibDurations);
display(fibonacciNotes);
const fibonacciPiece = {
  title: "Fibonacci",
  tempo: 120,
  tracks: [{ name: "Fibonacci", notes: fibonacciNotes }]
};
display(await jm.score(fibonacciPiece, { verovio }));
display(await jm.play(fibonacciPiece, { Tone }));
  </script>

  <script type="text/markdown">
The Fibonacci sequence applied with modulo creates a pattern that repeats after 16 steps (the Pisano period for 7), giving a sense of structure while still being mathematically interesting.
  </script>

</notebook>
