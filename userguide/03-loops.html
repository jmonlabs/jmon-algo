<!doctype html>
<notebook>
  <title>3. Loops</title>

  <script type="text/markdown">
# 3. Loops

This chapter covers the Loop class and techniques for creating repeating musical patterns:
- Basic loops and transformations
- Polyloops (multiple independent loops)
- Euclidean rhythms
- Phase shifting and rhythmic complexity
- Prime number cycles
- Isorhythm and beatcycle
  </script>

  <script type="module" pinned>
import jm from "../src/index.js";
import * as Tone from "npm:tone";
import * as ABCJS from "npm:abcjs";
  </script>

  <script type="text/markdown">
## 1. Basic Loop

A Loop in algo creates repeating musical patterns. The easiest way is to use `Loop.fromPattern()` which converts simple pitch/duration arrays to JMON format automatically.
  </script>

  <script type="module" pinned>
// Simple melodic loop using fromPattern()
const simpleLoop = jm.generative.loops.Loop.fromPattern(
  [60, 62, 64, 65],  // C, D, E, F
  [0.5, 0.5, 0.5, 0.5],
  {
    iterations: 4,
    label: 'Simple Melody'
  }
);

const simpleSequences = simpleLoop.toJMonSequences();
display(`Loop has ${simpleSequences.length} track(s)`);
display(`Total notes: ${simpleSequences[0].notes.length}`);
display("First few notes:", simpleSequences[0].notes.slice(0, 4));

const simplePiece = {
  title: "Simple Loop",
  tempo: 120,
  tracks: simpleSequences
};

display(jm.score(simplePiece, { ABCJS }));
display(await jm.play(simplePiece, { Tone }));
  </script>

  <script type="text/markdown">
## 2. Loop with Transformations

Loops can transform on each iteration using the `transpose` option, creating ascending or descending patterns.
  </script>

  <script type="module" pinned>
// Ascending loop that transposes up by 2 semitones each iteration
const ascendingLoop = jm.generative.loops.Loop.fromPattern(
  [60, 64, 67],  // C major triad
  [1, 1, 1],
  {
    iterations: 4,
    transpose: 2,  // Transpose up 2 semitones per iteration
    label: 'Ascending'
  }
);

const ascendingSeq = ascendingLoop.toJMonSequences()[0];
display(`Ascending loop notes: ${ascendingSeq.notes.length}`);
display("Pitches over iterations:");

for (let i = 0; i < 12; i += 3) {
  const iteration = Math.floor(i / 3) + 1;
  const pitches = ascendingSeq.notes.slice(i, i + 3).map(n => n.pitch);
  display(`  Iteration ${iteration}: ${pitches}`);
}

const ascendingPiece = {
  title: "Ascending Loop",
  tempo: 120,
  tracks: ascendingLoop.toJMonSequences()
};

display(await jm.play(ascendingPiece, { Tone }));
  </script>

  <script type="text/markdown">
## 3. Polyloops (Multiple Independent Loops)

Polyloops are multiple independent loops playing simultaneously. In algo, you create separate Loop instances for each voice and combine them in a composition.
  </script>

  <script type="module" pinned>
const loop1 = jm.generative.loops.Loop.fromPattern(
  [60, 64, 67],
  [0.5, 0.5, 0.5],
  { iterations: 8, label: 'Loop 1' }
);

const loop2 = jm.generative.loops.Loop.fromPattern(
  [48, 52, 55, 48],
  [1, 1, 1, 1],
  { iterations: 3, label: 'Loop 2' }
);

const loop3 = jm.generative.loops.Loop.fromPattern(
  [72, 76, 79, 76, 72],
  [2, 2, 2, 2, 2],
  { iterations: 2, label: 'Loop 3' }
);

display("Polyloop created with 3 independent loops:");
display(`  Loop 1: 3 notes × 8 iterations = ${loop1.toJMonSequences()[0].notes.length} notes`);
display(`  Loop 2: 4 notes × 3 iterations = ${loop2.toJMonSequences()[0].notes.length} notes`);
display(`  Loop 3: 5 notes × 2 iterations = ${loop3.toJMonSequences()[0].notes.length} notes`);

const polyloopPiece = {
  title: "Polyloop Example",
  tempo: 120,
  tracks: [
    ...loop1.toJMonSequences(),
    ...loop2.toJMonSequences(),
    ...loop3.toJMonSequences()
  ]
};

display(await jm.play(polyloopPiece, { Tone }));
  </script>

  <script type="text/markdown">
## 4. Euclidean Rhythms

Euclidean rhythms distribute beats evenly across a time span using the Euclidean algorithm. `Loop.euclidean(steps, pulses, pitches)` creates these mathematically perfect patterns.
  </script>

  <script type="module" pinned>
// Classic patterns
const euclidean_3_8 = jm.generative.loops.Loop.euclidean(8, 3, [60], 'Three over Eight');
const euclidean_5_8 = jm.generative.loops.Loop.euclidean(8, 5, [64], 'Five over Eight');
const euclidean_5_12 = jm.generative.loops.Loop.euclidean(12, 5, [67, 69], 'Five over Twelve');

display("Euclidean rhythms:");
display(`  3 pulses in 8 steps: ${euclidean_3_8.toJMonSequences()[0].notes.length} active notes`);
display(`  5 pulses in 8 steps: ${euclidean_5_8.toJMonSequences()[0].notes.length} active notes`);
display(`  5 pulses in 12 steps: ${euclidean_5_12.toJMonSequences()[0].notes.length} active notes`);

// Visualize the 5/8 pattern
const pattern_5_8 = euclidean_5_8.toJMonSequences()[0].notes;
const times_5_8 = pattern_5_8.map(n => Math.round(n.time));
display(`  5/8 pattern times: ${times_5_8}`);

// Play all three together
const euclideanPiece = {
  title: "Euclidean Rhythms",
  tempo: 120,
  tracks: [
    ...euclidean_3_8.toJMonSequences(),
    ...euclidean_5_8.toJMonSequences(),
    ...euclidean_5_12.toJMonSequences()
  ]
};

display(await jm.play(euclideanPiece, { Tone }));
  </script>

  <script type="text/markdown">
## 5. Isorhythm

Isorhythm maps durations to pitches, repeating until their least common multiple is reached. This creates evolving patterns when the pitch and duration sequence lengths differ.
  </script>

  <script type="module" pinned>
const pitches = [60, 62, 64, 65, 67];     // 5 pitches
const durations = [1, 0.5, 0.5, 1, 0.5];  // 5 durations
const isoPattern = jm.theory.rhythm.isorhythm(pitches, durations);

display("Isorhythm:");
display(`  Pitches: ${pitches.length}`);
display(`  Durations: ${durations.length}`);
display(`  Result: ${isoPattern.length} notes`);
display("First few:", isoPattern.slice(0, 5).map(n => ({
  pitch: n.pitch,
  duration: n.duration
})));

// Interesting pattern with different lengths
const complexPitches = [60, 64, 67];           // 3 pitches
const complexDurations = [1, 0.5, 0.5, 1];    // 4 durations
const complexPattern = jm.theory.rhythm.isorhythm(complexPitches, complexDurations);

display(`\nComplex isorhythm (3 pitches × 4 durations):`);
display(`  LCM(3, 4) = 12 notes`);
display(`  Result: ${complexPattern.length} notes`);

const isoPiece = {
  title: "Isorhythm",
  tempo: 120,
  tracks: [{ notes: complexPattern }]
};

display(await jm.play(isoPiece, { Tone }));
  </script>

  <script type="text/markdown">
## 6. Beatcycle

Beatcycle maps pitches to durations cyclically, setting timing based on cumulative durations.
  </script>

  <script type="module" pinned>
const beatPitches = [60, 62, 64, 65, 67, 69, 71, 72];
const beatDurations = [1, 0.5, 0.5, 1, 0.5, 0.5, 1, 1];
const beatPattern = jm.theory.rhythm.beatcycle(beatPitches, beatDurations);

display("Beatcycle pattern:");
display(`  Pitches: ${beatPitches.length}`);
display(`  Result: ${beatPattern.length} notes`);
display("First few:", beatPattern.slice(0, 3));

const beatPiece = {
  title: "Beatcycle",
  tempo: 120,
  tracks: [{ notes: beatPattern }]
};

display(await jm.play(beatPiece, { Tone }));
  </script>

  <script type="text/markdown">
## 7. Phase Shifting (Steve Reich style)

Phase shifting creates multiple copies of the same pattern starting at different times, creating complex polyrhythms. This technique was famously used by minimalist composer Steve Reich.
  </script>

  <script type="module" pinned>
const basePattern = [60, 62, 64, 62];
const baseDuration = 0.25;

// Create three loops with increasing offsets
const phaseLoop1 = jm.generative.loops.Loop.fromPattern(
  basePattern,
  Array(4).fill(baseDuration),
  { iterations: 16, offset: 0, label: 'Phase 1' }
);

const phaseLoop2 = jm.generative.loops.Loop.fromPattern(
  basePattern,
  Array(4).fill(baseDuration),
  { iterations: 16, offset: 0.05, label: 'Phase 2' }
);

const phaseLoop3 = jm.generative.loops.Loop.fromPattern(
  basePattern,
  Array(4).fill(baseDuration),
  { iterations: 16, offset: 0.10, label: 'Phase 3' }
);

display("Phase shifting (Steve Reich technique):");
display(`  Base pattern: ${basePattern}`);
display("  Loop 1 offset: 0.00 beats");
display("  Loop 2 offset: 0.05 beats");
display("  Loop 3 offset: 0.10 beats");
display("  Each loop: 16 iterations");

const phase1Notes = phaseLoop1.toJMonSequences()[0].notes;
const phase2Notes = phaseLoop2.toJMonSequences()[0].notes;
display(`  First note times: ${phase1Notes[0].time.toFixed(2)}, ${phase2Notes[0].time.toFixed(2)}`);

const phasePiece = {
  title: "Phase Shifting",
  tempo: 120,
  tracks: [
    ...phaseLoop1.toJMonSequences(),
    ...phaseLoop2.toJMonSequences(),
    ...phaseLoop3.toJMonSequences()
  ]
};

display(await jm.play(phasePiece, { Tone }));
  </script>

  <script type="text/markdown">
## 8. Prime Number Cycles

Using prime numbers for loop lengths creates interesting polyrhythmic patterns that take time to align, producing evolving textures.
  </script>

  <script type="module" pinned>
const prime3Loop = jm.generative.loops.Loop.fromPattern(
  [60, 63, 67],  // C minor triad
  [1, 1, 1],
  { iterations: 7, label: 'Prime 3' }
);

const prime5Loop = jm.generative.loops.Loop.fromPattern(
  [48, 50, 52, 53, 55],  // Bass line
  [0.5, 0.5, 0.5, 0.5, 0.5],
  { iterations: 5, label: 'Prime 5' }
);

const prime7Loop = jm.generative.loops.Loop.fromPattern(
  [72, 74, 76, 77, 79, 81, 83],  // High melody
  [2, 2, 2, 2, 2, 2, 2],
  { iterations: 2, transpose: -1, label: 'Prime 7' }
);

display("Prime number cycles:");
display(`  3-note pattern (×7) = ${prime3Loop.toJMonSequences()[0].notes.length} notes`);
display(`  5-note pattern (×5) = ${prime5Loop.toJMonSequences()[0].notes.length} notes`);
display(`  7-note pattern (×2) = ${prime7Loop.toJMonSequences()[0].notes.length} notes`);
display("  These patterns align at different times creating evolving textures");

const primePiece = {
  title: "Prime Number Cycles",
  tempo: 120,
  tracks: [
    ...prime3Loop.toJMonSequences(),
    ...prime5Loop.toJMonSequences(),
    ...prime7Loop.toJMonSequences()
  ]
};

display(await jm.play(primePiece, { Tone }));
  </script>

  <script type="text/markdown">
## 9. Complex Polyloop Example

Combining everything: sustained notes, arpeggios, bass, and rhythm to create a rich polyrhythmic texture.
  </script>

  <script type="module" pinned>
const sustained = jm.generative.loops.Loop.fromPattern(
  [84, 86, 88, 89],
  [4, 4, 4, 4],
  { iterations: 2, label: 'Sustained' }
);

const arpeggios = jm.generative.loops.Loop.fromPattern(
  [60, 64, 67, 64, 60, 67],
  [1, 1, 1, 1, 1, 1],
  { iterations: 4, label: 'Arpeggios' }
);

const bass = jm.generative.loops.Loop.fromPattern(
  [36, 36, 43, 36],
  [0.5, 0.5, 0.5, 0.5],
  { iterations: 12, label: 'Bass' }
);

const rhythm = jm.generative.loops.Loop.fromPattern(
  [72, 72, 72, null, 72, 72],  // null = rest
  [0.25, 0.25, 0.25, 0.25, 0.25, 0.25],
  { iterations: 16, label: 'Rhythm' }
);

display("Complex polyloop composition:");
display(`  Sustained layer: ${sustained.toJMonSequences()[0].notes.length} notes (slow)`);
display(`  Arpeggio layer: ${arpeggios.toJMonSequences()[0].notes.length} notes (medium)`);
display(`  Bass layer: ${bass.toJMonSequences()[0].notes.length} notes (steady)`);
display(`  Rhythm layer: ${rhythm.toJMonSequences()[0].notes.length} events (fast)`);

const complexPiece = {
  title: "Complex Polyloop",
  tempo: 120,
  tracks: [
    ...sustained.toJMonSequences(),
    ...arpeggios.toJMonSequences(),
    ...bass.toJMonSequences(),
    ...rhythm.toJMonSequences()
  ]
};

display(await jm.play(complexPiece, { Tone }));
  </script>

  <script type="text/markdown">
## 10. Direct JMON Format

You can also create loops directly in JMON format for maximum control over individual note properties like velocity and timing.
  </script>

  <script type="module" pinned>
const directLoop = new jm.generative.loops.Loop({
  'Direct Pattern': {
    notes: [
      { pitch: 60, duration: 0.5, time: 0, velocity: 0.8 },
      { pitch: 62, duration: 0.5, time: 0.5, velocity: 0.7 },
      { pitch: 64, duration: 0.5, time: 1.0, velocity: 0.9 },
      { pitch: 65, duration: 0.5, time: 1.5, velocity: 0.8 }
    ]
  }
});

display("Direct JMON loop:");
display("  Created with explicit note objects");
display("  Full control over time, velocity, and duration");
display(`  Notes: ${directLoop.toJMonSequences()[0].notes.length}`);
display(directLoop.toJMonSequences()[0].notes);
  </script>

  <script type="text/markdown">
## Summary

You've learned how to create complex rhythmic and melodic patterns using loops:

✓ **Basic loops** with `Loop.fromPattern()`
✓ **Transformations** with transpose option
✓ **Polyloops** for multi-layered textures
✓ **Euclidean rhythms** for mathematically perfect patterns
✓ **Isorhythm** for cyclic pitch/duration mapping
✓ **Beatcycle** for rhythm generation
✓ **Phase shifting** for Steve Reich-style minimalism
✓ **Prime number cycles** for complex polyrhythms
✓ **Direct JMON format** for maximum control

Next: **Chapter 4 - Minimalism** where you'll learn about additive/subtractive processes and tintinnabuli!
  </script>

</notebook>
